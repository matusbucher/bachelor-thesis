\chapter*{Introduction}
\addcontentsline{toc}{chapter}{Introduction}
\markboth{INTRODUCTION}{INTRODUCTION}

A \textit{reverse shell} is a technique commonly used to gain unauthorized remote access to a target system. It represents one of the two fundamental approaches to establishing a remote command shell, the other being a \textit{bind shell}. While both serve similar purposes -- enabling control over a compromised system -- their operational mechanics differ significantly.

In a bind shell scenario, the victim's machine opens a port and waits for incoming connections from the attacker (acting as a server). This requires the victim's system to be accessible over the network and typically demands the attacker to bypass firewalls or security controls that block unsolicited inbound connections.

A reverse shell literally inverts this model (hence the name). The victim's machine initiates an outbound connection to the attacker's machine, which now acts as a listener. This method is more stealthy and more successful in real-world scenarios, as outbound connections are less likely to be blocked by default firewall rules or NAT\footnote{network address translation} configurations.

Attackers typically create reverse shells by exploiting vulnerabilities such as command injection, buffer overflows, or insecure deserialization. Alternatively, they may trick users into executing malicious payloads through phishing or malware applications \cite{imperva}. Once a reverse shell is established, the attacker can run commands to exfiltrate data or deploy additional tools for persistence and lateral movement.

What makes a reverse shell particularly troublesome is its flexibility and ease of implementation. Many reverse shell techniques rely solely on tools and utilities that are already present on most operating systems. These methods of using legitimate tools available on the target's system are called "living-off-the-land", see more in \cref{sec:lotl}. Examples include network utilities like Netcat and Telnet, shell interpreters like Bash and PowerShell, general-purpose programming languages with socket support, and also tools not designed essentially for network connection like Awk. Many of the tools on the list are commonly available in standard operating system installations, most pre-installed by default. As a result, attackers can craft a working reverse shell even in heavily restricted environments, without the need to upload external binaries.

This thesis provides a comprehensive list of all currently known methods for creating a reverse shell. Numerous reverse shell cheat sheets published online (see \cite{cheatsheet1, cheatsheet2, cheatsheet3}) cover known techniques fairly well. So, in addition to listing all of them, we examine the minimal system requirements for each considered method. This can apply a trivial countermeasure against the concrete method by removing one of the tool's dependencies, such as a module or a library. Of course, we do not recommend relying solely on this countermeasure, as it may prevent the tool or other tools from running altogether. It can also be easily bypassed in misconfigured systems (for instance, through library hijacking) and is applied only to specific reverse shell techniques. Still, the list of dependencies can be helpful, e.g., for advanced detection mechanisms.

While the thesis primarily focuses on a thorough analysis and enumeration of reverse shell techniques, we will also briefly discuss the best practices for prevention, detection, and response to reverse shell incidents and the risks arising from the analysis's results at the end of the thesis.

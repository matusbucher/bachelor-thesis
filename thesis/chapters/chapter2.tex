\chapter{Framework for analysis}
\label{chap:framework}

The number of tools and techniques for creating a reverse shell is relatively high. Due to the limited scope of the thesis, we had to choose one specific system for the testing phase of the analysis. This chapter describes the testing environment and framework for implementing and evaluating reverse shell methods. Additionally, we define the format used to represent and document each method analyzed throughout the thesis.

\section{Testing environment}

In our analysis, the victim machine (on which techniques for establishing a reverse shell are tested) is simulated with a \texttt{chroot} environment for simplicity. The \texttt{chroot} command allows running a command or interactive shell with a specified directory as the apparent root directory \cite{chroot-man}. Therefore, the system simulated in the \texttt{chroot} environment has only access to files in the new 'root directory', which is convenient for determining requirements for a given method. If the method does not work, the environment lacks a dependent library, system tool, device, etc. The exact file, which was missing in the \texttt{chroot} directory, is either mentioned in the error message, or we can trace the actual system call for attempting to open the file (either \texttt{open()} or \texttt{openat()}) with the  \texttt{strace} tool. These techniques have been utilized to detect almost all requirements during the analysis.

The host system distribution (from which the \texttt{chroot} command is executed) is Ubuntu 24.04 LTS with a Linux 5.15 kernel and 64-bit x86 architecture. However, the commands and tools tested in this thesis should work on most GNU/Linux-based systems (if all dependencies are present).

The specifications for the attacker machine do not matter since the only requirement is an open port for catching the reverse shell connection. However, some methods require a slightly more complex listening setup than just opening a port. In that case, the process of setting up the listener will be explained in detail, together with an example command/script.


\section{Commands syntax and glossary}

For each system tool, we list one or more commands that, when run on the victim's machine, should try to connect to the attacker's machine (mainly using TCP), spawn a new shell session, and redirect its standard input and output to the connected socket. Alternatively, some methods do not redirect the standard file descriptors of the shell to the socket; instead, they read commands from the socket, execute them via the shell, and send output back to the socket. This ``indirect redirection'' is more common among scripting tools.

The attacker must have an open port ready to catch the reverse shell. It can be any available port, but standard ports for services like 80 for HTTP and 443 for HTTPS can disguise the reverse shell as an ordinary web traffic (\TODO{reference to the countermeasures section}). In most cases, a simple NetCat listener should be sufficient to catch the reverse shell.

\getcmdline{\commandpath{nc-listener.txt}}{bash}{*}{nc}{}{NetCat listener for catching reverse shell}{listener}

The non-obligatory option \texttt{-v} can be added for more verbose output. If the given method requires a more complex setup on the attacker's side, we will provide the necessary commands for the setup with an explanation.

The commands in this thesis use placeholders instead of specific values for generalization. They ensure clarity and adaptability across different scenarios, whether the actual value depends on the execution environment -- such as IP address -- or multiple equivalent values can be chosen -- such as the name of a temporary file. When implementing or testing, these placeholders should be replaced accordingly:

\setlength{\leftmargini}{5em}
\begin{itemize}
\item[\host] The attacker's IP address or domain.
\item[\port] The port number on which the attacker is listening.
\item[\shell] The shell to be spawned (e.g. \texttt{/bin/sh}, \texttt{/bin/bash}).
\item[\portt] The second port number on which the attacker is listening; must be different from \port.
\item[\tmp] A temporary file or directory used in specific methods (e.g., pipeline creation).
\end{itemize}
\setlength{\leftmargini}{2.5em}

\host\ and \port\ are naturally required in every method. \shell\ is also usually required and can be substituted with any available shell interpreter on the target system, even with a self-made interactive script or any other command. The standard input, output, and error output are all redirected to the socket. Therefore, the attacker can interact remotely with the shell (or another command).

\portt\ and \tmp\ are used only in several methods. \portt\ is, for instance, needed in telnet reverse shell (see \cref{lst:telnet1}), where the socket on port number \port\ serves as input for the shell and the socket on port number \portt\ serves as output. \tmp\ is used when the method requires a named pipeline (see \cref{lst:ncat2}) or a temporary directory for generated files (see \cref{lst:pip}).

If you would like to fork the reverse shell to run in the background (while the parent process -- e.g., shell -- will be running), add ampersand (\texttt{\&}) at the end of a command. A similar effect can be achieved if the command spawns \shell\ via shell interpreter (which most methods do, e.g., bash methods), in which case you can append ampersand at the end of this ``nested'' command.

After each command, it may follow a list of dependencies and occasional notes if additional information is appropriate. The implicit dependency for each command is that all shared objects (libraries) the binary requires are in the system. Of course, this is not an issue when using a statically linked binary. To identify all shared objects of the tool, use the \texttt{ldd} command:
\begin{cmdline}{bash}{*}{ldd}{}
ldd *\textcolor{placeholder}{\texttt{$\langle$path-to-binary$\rangle$}}*
\end{cmdline}

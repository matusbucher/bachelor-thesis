\chapter{Framework for analysis}
\label{chap:framework}

The number of tools and techniques for creating a reverse shell is relatively high. Due to the limited scope of the thesis, we had to choose one specific system for the testing phase of the analysis. This chapter describes the testing environment and framework for implementing and evaluating reverse shell methods. Additionally, we define the format used to represent and document each method analyzed throughout the thesis.

\section{Testing environment}
\label{testing-env}

In our analysis, the victim machine (on which techniques for establishing a reverse shell are tested) is simulated with a \texttt{chroot} environment for simplicity. The \texttt{chroot} command allows running a command or interactive shell with a specified directory as the apparent root directory \cite{chroot-man}. Therefore, the system simulated in the \texttt{chroot} environment has only access to files in the new 'root directory', which is convenient for determining requirements for a given method. If the method does not work, the environment lacks a dependent library, system tool, device, etc. The exact file, which was missing in the \texttt{chroot} directory, is either mentioned in the error message, or we can trace the actual system call for attempting to open the file (either \texttt{open()} or \texttt{openat()}) with the  \texttt{strace} tool. These techniques have been utilized to detect almost all requirements during the analysis.

The host system distribution (from which the \texttt{chroot} command is executed) is Ubuntu 24.04 LTS with a Linux 5.15 kernel and 64-bit x86 architecture. However, the commands and tools tested in this thesis should work on most GNU/Linux-based systems (if all dependencies are present).

The specifications for the attacker machine do not matter since the only requirement is an open port for catching the reverse shell connection. However, some methods require a slightly more complex listening setup than just opening a port. In that case, the process of setting up the listener will be explained in detail, together with an example command/script.


\section{Commands syntax and glossary}

For each system tool, we list one or more commands that, when run on the victim's machine, should try to connect to the attacker's machine (mainly using TCP), spawn a new shell session, and redirect its standard input and output to the connected socket. Alternatively, some methods do not redirect the standard file descriptors of the shell to the socket; instead, they read commands from the socket, execute them via the shell, and send output back to the socket. This ``indirect redirection'' is more common among scripting tools.

The attacker must have an open port ready to catch the reverse shell. It can be any available port, but standard ports for services like 80 for HTTP and 443 for HTTPS can disguise the reverse shell as an ordinary web traffic (\TODO{reference to the countermeasures section}). In most cases, a simple NetCat listener should be sufficient to catch the reverse shell.

\getcmdline{\commandpath{nc-listener.txt}}{bash}{*}{nc}{}{NetCat listener for catching reverse shell}{listener}

The non-obligatory option \texttt{-v} can be added for more verbose output. If the given method requires a more complex setup on the attacker's side, we will provide the necessary commands for the setup with an explanation.

The commands in this thesis use placeholders instead of specific values for generalization. They ensure clarity and adaptability across different scenarios, whether the actual value depends on the execution environment -- such as IP address -- or multiple equivalent values can be chosen -- such as the name of a temporary file. When implementing or testing, these placeholders should be replaced accordingly:

\setlength{\leftmargini}{5em}
\begin{itemize}
\item[\host] The attacker's IP address or domain.
\item[\port] The port number on which the attacker is listening.
\item[\shell] The shell to be spawned (e.g. \texttt{/bin/sh}, \texttt{/bin/bash}).
\item[\portt] The second port number on which the attacker is listening; must be different from \port.
\item[\tmp] A temporary file or directory used in specific methods (e.g., pipeline creation).
\end{itemize}
\setlength{\leftmargini}{2.5em}

\host\ and \port\ are naturally required in every method. \shell\ is also usually required and can be substituted with any available shell interpreter on the target system, even with a self-made interactive script. Still, some methods do not allow the use of an arbitrary shell, and the commands sent through the socket are executed by the default shell (\texttt{/bin/sh} in most cases).

Theoretically, \shell\ could be defined together with shell options, since it is passed as a shell command in most methods. An interesting option, which is supported on almost every standard shell interpreter, is the \texttt{-i} option, which makes the shell session ``interactive''. That means we get a nice shell on the attacker's side rather than a raw output of executed commands. Nevertheless, it was not tested for all methods and thus may not work everywhere (it could be a problem for some function calls in reverse shell scripts that expect specific arguments).

\portt\ and \tmp\ are used only in several methods. \portt\ is, for instance, needed in telnet reverse shell (see \cref{lst:telnet1}), where the socket on port number \port\ serves as input for the shell and the socket on port number \portt\ serves as output. \tmp\ is used when the method requires a named pipeline (see \cref{lst:ncat2}) or a temporary directory for generated files (see \cref{lst:pip}).

Some methods use a scripting language or compiler to establish a reverse shell, especially the methods in \cref{program-interpreters} and \cref{program-compilers}. In such cases, a script/code with multiple lines and comments will be provided for better understanding and clarity. Together with the script, we will show how to run the script (or compile and run the code) as well as how to change it into a ``one-liner'' command without creating a script file (which might not always be possible). In order not to repeat the whole script for each variant or to refer to the files, we use more placeholders:

\setlength{\leftmargini}{10em}
\begin{itemize}
\item[\script] Referenced script compressed into one line using a line separator (usually a semicolon). Comments can be omitted.
\item[\scriptfile] Path to the script file.
\item[\codefile] Path to the source code (semantically the same as the previous, but used to distinguish interpreted script from compiled code).
\end{itemize}
\setlength{\leftmargini}{2.5em}

In some scenarios, running the reverse shell in the background asynchronously can be useful for more difficult detection. This can be done by appending an ampersand (\texttt{\&}) at the end of the command \cite{bash-gnu-man} in most POSIX-compliant shell interpreters. However, some reverse shell methods are composed of multiple commands, or even loops (see \cref{lst:curl}). In that case, we need to group those commands with curly brackets and append \texttt{\&} to the whole group:

\begin{cmdline}{bash}{*}{}{}
{ *\textcolor{placeholder}{\texttt{$\langle$command1$\rangle$}}*; *\textcolor{placeholder}{\texttt{$\langle$command2$\rangle$}}*; ...; } &
\end{cmdline}

After each example command or script for a given method, it may follow a list of dependencies and an occasional note (if additional information is appropriate). The implicit dependency for each command is that all shared objects (dynamic libraries) required by the tools used in the command are in the system. To print shared object dependencies of the tool's binary, use the \texttt{ldd} command together with the \texttt{which} command that shows the full path of the commands:
\begin{cmdline}{bash}{*}{ldd,which}{}
ldd $(which *\textcolor{placeholder}{\texttt{$\langle$command$\rangle$}}*)
\end{cmdline}
%$

Of course, this is not an issue when using a statically linked binary.


\section{Testing framework}

For effective testing and as an applicable result of gathering reverse shell methods, we constructed a Makefile with the exact implementations listed in the thesis, including both the reverse shell commands and the required listeners. Following the idea of placeholders for a general case, the host, port, and other variables used in Makefile can be easily configured with the attached \texttt{configure} script (which is a \texttt{bash} script). Both files are available on a public GitHub repository \TODO{provide repository link}.

To configure the Makefile, issue:

\getcmdline{\commandpath{configure.txt}}{bash}{*}{}{}{Configuration of the Makefile}{configure}

The values correspond to placeholders described earlierand will be used from now on in the Makefile targets. To list all available methods in the Makefile, issue:

\getcmdline{\commandpath{make-show.txt}}{bash}{*}{make}{}{Listing available methods from the Makefile}{make-show}

The listed methods are also Makefile targets, which run the corresponding reverse shell method or open a listener. To see a method command(s) without actual execution, issue:

\getcmdline{\commandpath{make-method-show.txt}}{bash}{*}{make}{}{Printing a command for the particular method from the Makefile}{make-method-show}

We used this Makefile for running reverse shell commands from the \texttt{chroot} process inside a dedicated directory with a \texttt{bash} session, which, as mentioned in the \cref{testing-env}, represents the victim system. The minimal requirements for the \texttt{chroot} environment to be able to test any method are therefore \texttt{bash} and \texttt{make} binaries together with dependent dynamic libraries and the Makefile. This was a ``starting'' state for testing each method to identify the method's dependencies correctly.

We tested each reverse shell connecting to localhost for simplicity and security reasons. We caught reverse shells in a separate terminal session (not within \texttt{chroot} environment, but on the host system). This also ensured that no possible firewall settings or security tools would block the reverse shell attempts during testing. Although irrelevant, these are all the values we used in testing:

\setlength{\leftmargini}{5em}
\begin{itemize}
\item[\host\ :] \texttt{127.0.0.1} (localhost)
\item[\port\ :] \texttt{4444}
\item[\shell\ :] \texttt{/bin/bash}
\item[\portt\ :] \texttt{4445}
\item[\tmp\ :] \texttt{/tmp/f}
\end{itemize}
\setlength{\leftmargini}{2.5em}

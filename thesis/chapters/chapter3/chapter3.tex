\newcommand{\commandpath}[1]{chapters/chapter3/commands/#1}
\newcommand{\dpd}[1]{\begin{adjustwidth}{10pt}{0pt}\small \textbf{Dependencies:} #1 \end{adjustwidth}}
\newcommand{\notte}[1]{\begin{adjustwidth}{10pt}{0pt} \small \textbf{Note:} #1 \end{adjustwidth}}
\newcommand{\version}[1]{\textbf{Version:} #1}

\chapter{Methods of establishing a reverse shell}
\label{chap:methods}

This chapter explores established methods and techniques for initializing a reverse shell from a remote server. Each method is characterized by a system tool, software, or a programming language with its interpreter/compiler. We will not categorize them by what misconfiguration could cause a vulnerability that these methods could exploit, since it heavily depends on the system and what services are running on it. However, we will talk about good practices and countermeasures against reverse shell in general in the chapter <link>.

For each method, we show an actual command line example(s) of how to use the tool/software for the reverse shell, taking into account the testing environment described in the previous chapter. Furthermore, as mentioned, we list all system dependencies needed for the given method to execute successfully. If a method has excessive dependencies, such as dynamic libraries or modules, a complete list will be provided in the appendix.


\section{Network tools}

First, we list the most apparent and straightforward candidates capable of creating a reverse shell: network tools. These tools are meant for network communication and can, therefore, be used really easily if they are available to the attacker.


\subsection{NetCat (\texttt{nc}/\texttt{ncat})}

\version{7.94SVN (Nmap Project)}

NetCat is a well-known tool for reading from and writing to network connections using TCP or UDP and is preinstalled on many Linux distributions. There are multiple implementations of NetCat -- GNU's traditional implementation, OpenBSD, or the Nmap project version of NetCat called \texttt{ncat}, which we have used for testing.

Not every implementation supports the \texttt{-e} (or \texttt{-{}-exec}) or \texttt{-c} (or \texttt{-{}-sh-exec}) option, which causes the program to execute the given command. Option \texttt{-e} runs \texttt{exec <command>}, while \texttt{-c} executes via \texttt{/bin/sh} \cite{ncat-man}. The traditional GNU and the Nmap implementation should have this option, but the OpenBSD implementation has removed it for security reasons \cite{nc-man}.

\getcmdline{\commandpath{ncat1.txt}}{bash}{*}{ncat}{}{NetCat reverse shell (version 1, with option \texttt{-e})}{ncat1}

\notte{Standard error output of executed commands is not redirected to the socket. Option \texttt{-c} can be used instead of \texttt{-e} with the same syntax, but \texttt{/bin/sh} is needed in that case.}

However, when dealing with NetCat without the \texttt{-e} or \texttt{-c} option, the restriction can be easily bypassed by redirecting file descriptors, as shown in the \cref{lst:ncat2}. It creates a named pipe \tmp\ for connecting standard inputs and outputs of shell and NetCat processes.

\getcmdline{\commandpath{ncat2.txt}}{bash}{*}{mkfifo,ncat,rm}{}{NetCat reverse shell (version 2, with a named pipe)}{ncat2}

\dpd{\texttt{mkfifo}, \texttt{rm} (not really needed)}


\subsection{Telnet (\texttt{telnet})} \label{telnet}

\version{2.5 (GNU inetutils)}

Telnet is another popular client-server network protocol that establishes bidirectional interactive text-based communication using the TCP protocol (although now considered a legacy tool not recommended for secure communication). Unlike NetCat, Telnet does not offer a direct option to execute a command and send its output through the network. However, this limitation can be solved again by using standard Unix pipelines.

In the first example (\cref{lst:telnet1}), we use two Telnet instances. One is for receiving commands that the chosen shell will execute, and then their output will be sent through the second telnet connected to a different port (it can also be connected to a different host). The attacker needs to set up two distinct listeners accordingly.

\getcmdline{\commandpath{telnet1.txt}}{bash}{*}{telnet}{}{Telnet reverse shell (version 1, with anonymous pipes)}{telnet1}

\notte{The socket with port number \port\ serves as standard input for the shell while the socket with port number \portt\ serves as standard output and standard error output.}

Two Telnet instances were needed because anonymous Unix pipes are unidirectional. However, we can use a named pipe (like with NetCat) to create a reverse shell with only one telnet instance.

\getcmdline{\commandpath{telnet2.txt}}{bash}{*}{mkfifo,telnet,rm}{}{Telnet reverse shell (version 2, with a named pipe)}{telnet2}

\dpd{\texttt{mkfifo}, \texttt{rm}}


\subsection{Socket (\texttt{socket})}

\version{1.1}

Socket is a relatively old, lesser-known network utility for creating and interacting with sockets directly from the command line. It does not usually come preinstalled (like NetCat) on most modern distributions. It has a \texttt{-p} (\texttt{program}) option, which runs the given command for each established connection, and its standard input, standard output, and standard error channels are automatically redirected to the socket \cite{socket-man}.

\getcmdline{\commandpath{socket.txt}}{bash}{*}{socket}{}{Socket reverse shell}{socket}

\dpd{\texttt{/bin/sh} shell (\texttt{socket} executes the command specified with the \texttt{-p} option with this shell)}


\subsection{OpenSSL (\texttt{openssl})}

\version{3.0.13}

OpenSSL is a widely used toolkit that implements the SSL and TLS network protocols and related cryptography standards. It provides many commands with a variety of options and arguments, particularly for network connections between SSL/TLS clients and servers.

For the reverse shell, we will run the client on the victim's side. Since the client 'speaks' only in SSL/TLS, we need to establish a server on the attacker's side that also speaks in SSL/TLS. A simple NetCat listener will not be adequate, so we also use the \texttt{openssl} command to create a server on the attacker's side. It can be done using the following commands:

\getcmdline{\commandpath{openssl-listener.txt}}{bash}{*}{openssl}{}{Setting up an SSL/TLS server for catching OpenSSL reverse shell}{openssl-listener}

The first command generates a self-signed X.509 certificate and a new RSA 4096-bit key. Then, it saves the key and the certificate to the specified \texttt{.pem} files. The \texttt{-noenc} option makes the private key unencrypted (no password is required to access it later).

The second command runs \texttt{openssl} in server mode for listening on a specified port. The certificate and key are loaded from the \texttt{.pem} files created with the first command, and the \texttt{-quiet} option will suppress the printing of session and certificate information (recommended, but not mandatory). \cite{openssl-doc}

With the running SSL/TLS server, we can launch the client on the victim's machine and initialize the reverse shell with this command:

\getcmdline{\commandpath{openssl.txt}}{bash}{*}{mkfifo,openssl,rm}{}{OpenSSL reverse shell}{openssl}

\dpd{\texttt{mkfifo}, \texttt{rm}}

We use the same technique with named pipe as we did with NetCat or Telnet methods. Here, the \texttt{-quiet} option is neccessary. It suppresses all non-essential output (session details, certificate verification info, and other debug output), which would not be valid input for the shell interpreter and probably cause it to exit or fail unpredictably. In our tests, the connection was closed immediately when we used the command without the \texttt{-quiet} option.


\subsection{cURL (\texttt{curl})}

\version{8.5.0}

cURL ("client for URL") is a versatile tool for transferring data to or from a server using various protocols, most commonly HTTP and HTTPS. In this reverse shell scenario, we will use \texttt{curl} command to periodically make HTTP requests to an attacker's server to fetch commands via the GET method and send back their output via the POST method.

Again, we will need a special listener on the attacker's side, this time an HTTP server that will handle the request as described earlier. We provide a simple Python script that should do the work:

\getcmdline{\commandpath{curl-listener.txt}}{python}{*}{}{ShellHandler,do_GET,do_POST}{Setting up custom HTTP server for catching cURL reverse shell}{curl-listener}

With the \texttt{curl} command on the victim's side, we can send the mentioned GET and POST requests together with executing fetched commands in a loop:

\getcmdline{\commandpath{curl.txt}}{bash}{*}{curl}{}{cURL reverse shell}{curl}

Option \texttt{-s} (or \texttt{-{}-silent}) is for the silent mode, which does not print show progress meter or error messages, only the HTTP response. It is needed in the first \texttt{curl} command to get just the command without auxiliary output. Option \texttt{-X} (or \texttt{-{}-request}) specifies the request method, and option \texttt{-d} (or \texttt{-{}-data}) sends the specified data in a POST request. \cite{curl-man}

It is worth mentioning that this method uses a polling-based approach, which does not require a persistent TCP connection, unlike previous methods. Apart from appearing as common web traffic (and therefore harder to detect), the loop can persist even when the attacker becomes offline, so no additional actions on the victim's machine are required if the attacker wants to obtain the reverse shell again later.


\section{Command-line interpreters}

Another straightforward way to get a reverse shell is to use shell interpreters themselves. Since some shells have built-in support for simple TCP and UDP network communication, they can be used to connect to the attacker without using other system tools. This section lists all standard and popular shells capable of creating a reverse shell alone. At the end of the section, we also mention shell interpreters that do not support this feature (\cref{no-network-shells}).

The example commands in this section follow the \inlinecmdline{\shell\ -c '\textcolor{placeholder}{$\langle$command$\rangle$}'} format, where the \texttt{-c} option tells the shell to execute the given command string. All shell interpreters support this option mentioned in this section. If you are already running an interactive session in the given shell, you can execute just the \texttt{\textcolor{placeholder}{$\langle$command$\rangle$}} portion directly. However, we use the complete form for consistency and portability, ensuring the command works regardless of the current shell environment.


\subsection{Bash (\texttt{bash})}

\version{5.2.21 (GNU)}

First on the list is the default and most commonly used shell on most Linux distributions, the Bash shell. It was designed as a free and enhanced alternative for the classic Bourne shell (sh) and other proprietary Unix shells \cite{gnu-about}. It also offers extensive scripting capabilities and, importantly for this context, supports TCP and UDP communication through special file descriptors located in the \texttt{/dev/tcp/} and \texttt{/dev/udp/} pseudo-filesystems.

Bash treats these pseudo-file paths semantically like regular files, which allows standard input and output redirection to be used with them. This makes establishing a reverse shell connection possible using simple redirection syntax.

\getcmdline{\commandpath{bash.txt}}{bash}{*}{bash}{}{Bash reverse shell}{bash}


\subsection{Korn shell (\texttt{ksh}/\texttt{ksh93}/\texttt{rksh}/\texttt{rksh93})}

\version{93u+m/1.0.8 (ATT)}

Korn shell is a shell developed by David Korn as a successor to the Bourne shell. It was originally proprietary software, which led to the creation of several free and open-source alternatives, including Bash. There are actually many versions and clones of Korn shell, like \texttt{pdksh}, \texttt{mksh} and others, while the original is \texttt{ksh88}.

However, the version that added support for network communication is the newer \texttt{ksh93} version. It is realized through the same \texttt{/dev/tcp/} and \texttt{/dev/udp/} pseudo-filesystems as with Bash. Creation of reverse shell is thus done exactly as in the \cref{lst:bash}.

\getcmdline{\commandpath{ksh.txt}}{bash}{*}{ksh}{}{Korn shell reverse shell}{ksh}

Additionally, there are two other clones of \texttt{ksh93} which also support this feature -- \texttt{dtksh} (Desktop Korn shell, a fork included as part of CDE) and \texttt{tksh} (a fork that provides access to the Tk widget toolkit) \cite{kornshell-wiki}. The Korn shell variants, which do not have networking features, are listed at the end of the section (\cref{no-network-shells}).

\subsection{Z shell (\texttt{zsh})}

\version{5.9}

Z shell is a feature-rich Unix shell offering advanced scripting capabilities and customization options. It is the default login shell on macOS and Kali Linux. Unlike Bash or Korn shell, Z shell does not support the \texttt{/dev/tcp/} or \texttt{/dev/udp/} pseudo-filesystems. Instead, additional features of the Z shell, including networking, are in modules, separate from the shell's core. Each module may be linked into the shell at build time or dynamically linked while the shell is running. \cite{zshmodules-man}

The module \texttt{zsh/net/tcp}, which provides manipulation of TCP sockets, can be loaded with the \texttt{zmodload} keyword. With the module loaded, we can run the \texttt{ztcp} command, which opens a new TCP connection to the specified host and port. The argument of option \textbf{-d} will be taken as the target file descriptor for the connection \cite{zsh-net-tcp-doc}. We can then redirect the standard input and output of the new shell session to this file descriptor.

\getcmdline{\commandpath{zsh.txt}}{bash}{*}{zsh}{}{Z shell reverse shell}{zsh}

\dpd{\texttt{zsh/net/tcp.so} \footnote{usually located somewhere in \texttt{/usr/lib/}}}


\subsection{Scheme shell (\texttt{scsh})}

\TODO{maybe remove this method}


\subsection{PowerShell (\texttt{pwsh}/\texttt{powershell})}

\version{7.5.0}

PowerShell is a powerful shell and scripting language developed by Microsoft. Unlike traditional shells, it is object-oriented. PowerShell comes preinstalled on modern Windows systems, but additionally, an open-source, cross-platform version -- \texttt{pwsh} -- is available for Linux and macOS. The following method is compatible on all platforms.

Reverse shell via PowerShell is more complicated than previous shells. To work with network connections, it requires using .NET classes and managing multiple objects such as sockets, streams, and others. Hence, we will need a PowerShell script rather than a simple command with redirections (this makes this method closer to the ``programming language interpreters'' category -- \cref{program-interpreters}). Nevertheless, it can still be made into a one-liner using \texttt{-c} option and separating lines from the script with a semicolon.

\getcmdline{\commandpath{pwsh-script.txt}}{bash}{*}{}{}{PowerShell reverse shell script}{pwsh-script}

\dpd{\texttt{pwsh.dll} \footnote{usually located in \texttt{/opt/microsoft/powershell/}}, .NET}

As mentioned, here is how it could be executed as a one-line command:

\getcmdline{\commandpath{pwsh-oneline.txt}}{bash}{*}{pwsh}{}{PowerShell one-line reverse shell}{pwsh-oneline}


\subsection{Shells without native network support}
\label{no-network-shells}

In contrast to command-line interpreters that can independently establish network connections, we outline popular shells that lack this capability \cite{shell-comparison-wiki}. Without additional programs that facilitate network communication, these shells do not inherently pose a risk of spawning a reverse shell. However, this does not suggest that other security countermeasures should be disregarded when mitigating reverse shell attack vectors.

\begin{itemize}

\item \textbf{Bourne shell} (\texttt{sh}) -- The standard shell for the Version 7 Unix system; has been replaced by its advanced variants. Be aware that the original binary \texttt{/bin/sh} is just a link to another compatible shell on most modern Unix-like distributions.

\item \textbf{Almquist shell} (\texttt{ash}) and \textbf{Debian Almquist shell} (\texttt{dash}) -- Lightweight and POSIX-compliant shells designed for minimal environments, commonly used in embedded systems and as the default shell for Debian-based distributions.

\item The original Korn shell (\texttt{ksh88}), \textbf{Public domain Korn shell} (\texttt{pdksh}), \textbf{MirBSD Korn shell} (\texttt{mksh}), \textbf{Portable OpenBSD Kown shell} (\texttt{oksh}) and other variants and forks not based on \texttt{ksh93}.

\item \textbf{C shell} (\texttt{csh}) and \textbf{TENEX C shell} (\texttt{tcsh}) -- Shells with a syntax inspired by the C programming language. \texttt{tcsh} extends \texttt{csh} with interactive features like command-line editing and history.

\item \textbf{Friendly interactive shell} (\texttt{fish}) -- A user-friendly shell with advanced features like syntax highlighting, autosuggestions, and a scripting syntax distinct from POSIX-compliant shells.

\item \textbf{rc shell} (\texttt{rc}) -- The default shell for the Plan 9 operating system, also available on Unix systems.

\item \textbf{Stand-alone shell} (\texttt{sash}) -- A statically linked shell designed for system recovery and emergency maintenance.

\item \textbf{Command Prompt} (\texttt{cmd}) -- The default legacy command-line interpreter for Windows.

\end{itemize}


\section{Programming language interpreters}
\label{program-interpreters}

In this section, we cover common interpreted programming or scripting languages. Every proper programming language should be capable of opening a TCP socket for network communication (perhaps with some standard module), running a command from the operating system, redirecting standard file descriptors to the socket — and, therefore, creating a reverse shell. The interesting part is which dynamic libraries and modules are requisite for each method.

Almost all examples in this section are written as script files, but, as with the PowerShell example (\cref{lst:pwsh-script}), they can easily be turned into one-liners with specific options or pipelines. We will specify how to do this for each method. The example scripts also include comments with decent explanations of what the script does.


\subsection{Python (\texttt{python/python3})}

\version{3.12.3}

Python is one of the most popular programming languages, known for its simple, readable syntax and vast standard library. Among the example scripts in this section, the following one for Python reverse shell is relatively short and straightforward. It also requires a small number of Python modules.

\getcmdline{\commandpath{python-script.txt}}{python}{*}{}{}{Python reverse shell script}{python-script}

\dpd{Python modules (see \cref{tab:python-dpd} in the appendix)}

\notte{We tested and analyzed dependent modules for the Python 3 version, but the script is also compatible with the older Python 2.x versions (but perhaps with different dependencies).}

Now, the script can be turned into a one-liner using Python's \texttt{-c} option \cite{python-man} and separating lines with semicolons. The for loop, however, must be compressed to a list comprehension as \inlinecmdline{[os.dup2(sock.fileno(),fd) for fd in (0,1,2)]} or expanded into three separate lines (one for each file descriptor).

\getcmdline{\commandpath{python-oneline.txt}}{bash}{*}{python}{}{Python one-line reverse shell}{python-oneline}


\subsection{Perl (\texttt{perl})}

\version{5.38.2}

Perl is a high-level language designed as a general-purpose Unix scripting language to facilitate report processing. Although less commonly used today than Python or other scripting languages, Perl remains a staple in many legacy systems. The script for the reverse shell is, again, really straightforward, with a few dependent modules.

\getcmdline{\commandpath{perl-script.txt}}{perl}{*}{}{}{Perl reverse shell script}{perl-script}

\dpd{\texttt{/dev/null}, Perl modules (see \cref{tab:perl-dpd} in the appendix), loadable object \texttt{auto/Socket/Socket.so} (for module \texttt{Socket})}

To make it into a one-line command, use the \texttt{-e} (or \texttt{-E}) option with the compressed script. \cite{perl-man}

\getcmdline{\commandpath{perl-oneline.txt}}{bash}{*}{perl}{}{Perl one-line reverse shell}{perl-oneline}

\subsubsection{Comprehensive Perl Archive Network (\texttt{cpan})}

\version{Perl 5.38.2}

CPAN is a large repository of Perl modules and libraries. It is typically accessed using the \texttt{cpan} command-line tool, which allows users to search for, install, and manage Perl modules directly from the terminal. When run without arguments, the tool starts an interactive CPAN session, where the exclamation mark (\texttt{!}) executes arbitrary commands. While this feature is intended to allow running shell commands (such as \inlinecmdline{! ls}), it can also interpret and execute valid Perl code. \cite{cpan-man}

Hence, we could start the \texttt{cpan} session and enter the compressed Perl code from \cref{lst:perl-script} prefixed with \texttt{!}. We can also pass the line to \texttt{cpan} through a pipeline with the \texttt{echo} command, as shown below.

\getcmdline{\commandpath{cpan-oneline.txt}}{bash}{*}{echo,cpan}{}{Cpan one-line reverse shell}{cpan-oneline}

\dpd{\texttt{perl}, dependencies from \cref{lst:perl-script} (except \texttt{/dev/null}), additional Perl modules and loadable objects (see \cref{tab:cpan-dpd-mod,tab:cpan-dpd-so} in the appendix)}


\subsection{PHP (\texttt{php})}

\version{8.3.6}

PHP is a widely used server-side scripting language. It is primarily designed for web development but capable of general-purpose scripting. It has built-in networking and process control functions, allowing quick and effective reverse shell implementations. That makes PHP reverse shell especially useful in web-based attack scenarios like file upload or remote code execution vulnerabilities.

Our minimal example of a PHP reverse shell consists of only two function calls. Since these functions are part of PHP's core, loading additional modules is not required (which makes the dependency list minimalistic).

\getcmdline{\commandpath{php-script.txt}}{php}{*}{}{}{PHP reverse shell script)}{php-script}

\dpd{\texttt{UTC} file\footnote{usually located in \texttt{/usr/share/zoneinfo/}; without it, the \texttt{php} tool does not work at all}, \texttt{sh} shell (\texttt{php} uses it to execute commands)}

Additionally, the \inlinecmdline{exec("\shell\ <\&3 >\&3 2>\&3")} call can be substituted with other function calls with the exact dependencies:

\begin{itemize}

\item \inlinecmdline{shell\_exec("\shell\ <\&3 >\&3 2>\&3")} or \inlinecmdline{`\shell\ <\&3 >\&3 2>\&3`} (with the backtick symbols) -- These are semantically equivalent.
\item \inlinecmdline{system("\shell\ <\&3 >\&3 2>\&3")}
\item \inlinecmdline{passthru("\shell\ <\&3 >\&3 2>\&3")}
\item \inlinecmdline{popen("\shell\ <\&3 >\&3 2>\&3", "r")}
\item \inlinecmdline{proc\_open("\shell\", array(0=>\$sock, 1=>\$sock, 2=>\$sock), \$pipes)} -- This will fork the shell session without the need to use \texttt{\&}. The \texttt{\$sock} variable is the socket returned from the \inlinecmdline{fsockopen("\host",\port)} call (see the comment in the script).

\end{itemize}

The option \texttt{-r} (or \texttt{-{}-run}) of the PHP command line tool allows us to run the code as one command \cite{php-man}.

\getcmdline{\commandpath{php-oneline.txt}}{bash}{*}{php}{}{PHP one-line reverse shell}{php-oneline}


\subsection{Ruby (\texttt{ruby})}

\version{3.2.3}

\getcmdline{\commandpath{ruby-script1.txt}}{ruby}{*}{}{}{Ruby reverse shell script (version 1)}{ruby-script1}

\dpd{Ruby module \texttt{socket}\footnote{usually located in \texttt{/usr/lib/ruby/<version>/}} and loadable object \texttt{socket.so}\footnote{usually located somewhere in \texttt{/usr/lib/}}}

\getcmdline{\commandpath{ruby-script2.txt}}{ruby}{*}{}{}{Ruby reverse shell script (version 2)}{ruby-script2}

\dpd{same dependencies from \cref{lst:ruby-script1}, \texttt{sh} shell (\texttt{popen} function uses it to execute the command)}

\getcmdline{\commandpath{ruby-oneline.txt}}{bash}{*}{ruby}{}{Ruby one-line reverse shell}{ruby-oneline}


\subsubsection{Interactive Ruby Shell (\texttt{irb})}

\version{1.6.2}

\getcmdline{\commandpath{irb-oneline.txt}}{bash}{*}{echo,irb}{}{IRB one-line reverse shell}{irb-oneline}

\dpd{\texttt{ruby} \footnote{or \texttt{ruby<version>}, since some modules explicitly call this binary}, dependencies from either \cref{lst:ruby-script1}\ or \cref{lst:ruby-script2}, \texttt{/dev/null}, Ruby modules, loadable objects, special gemspec files (see \cref{tab:irb-dpd-mod,tab:irb-dpd-so,tab:irb-dpd-gemspec} in the appendix)}


\subsection{JavaScript runtime environments}

\subsubsection{Node.js (\texttt{node})}

\version{18.19.1}

\getcmdline{\commandpath{node-script.txt}}{java}{*}{}{}{Node.js reverse shell script (JavaScript)}{node-script}

\dpd{JavaScript modules (see \cref{tab:node-dpd} in the appendix)}

\getcmdline{\commandpath{node-oneline.txt}}{bash}{*}{node}{}{Node.js one-line reverse shell}{node-oneline}


\subsubsection{Nashorn engine (\texttt{jjs} and \texttt{jrunscript})}

\version{1.8.0\_442}

\getcmdline{\commandpath{nashorn-script.txt}}{java}{*}{}{}{Nashorn engine reverse shell script (JavaScript)}{nashorn-script}

\TODO{dependencies}

\getcmdline{\commandpath{jjs-oneline.txt}}{bash}{*}{echo,jjs}{}{jjs one-line reverse shell}{jjs-oneline}

\getcmdline{\commandpath{jrunscript-oneline.txt}}{bash}{*}{jrunscript}{}{jrunscript one-line reverse shell}{jrunscript-oneline}


\subsection{Julia (\texttt{julia})}

\version{1.11.4}

\getcmdline{\commandpath{julia-script.txt}}{perl}{^}{}{}{Julia reverse shell script}{julia-script}

\dpd{dynamic libraries (see \cref{tab:julia-dpd} in the appendix), Julia module \texttt{Sockets} (files \texttt{Sockets.jl} and \texttt{Sockets/Project.toml}\footnote{usually located in \texttt{/usr/local/share/stdlib/<version>}})}

\getcmdline{\commandpath{julia-oneline.txt}}{bash}{*}{julia}{}{Julia one-line reverse shell}{julia-oneline}


\section{Compiled programs}

So far, we have mentioned reverse shell methods that utilize one or more software tools with CLI to establish a connection back to the attacker. Another approach could be running an executable, e.g., from compiled code. In this subsection, we list methods that require compilation (not necessarily into a binary that runs the OS) before running and, therefore, cannot be executed directly from the command line.

\subsection{C (\texttt{gcc})}

\version{13.3.0}

\getcmdline{\commandpath{gcc.txt}}{C}{|}{}{main,socket,exit,htons,inet_pton,connect,close,dup2,execl}{GCC reverse shell}{gcc}

\subsection{Java (\texttt{javac})}

\version{21.0.6}

\getcmdline{\commandpath{javac.txt}}{Java}{*}{}{}{Java reverse shell}{javac}


\section{Other tools}

\subsection{Socat (\texttt{socat})}

\getcmdline{\commandpath{socat.txt}}{bash}{*}{socat}{}{Socat reverse shell}{socat}

\texttt{stderr} option redirects standard error output to the socket. Additional options can be added at the end of the command (separated by a single comma) \cite{socat-man}:

\setlength{\leftmargini}{5em}
\begin{itemize}
\item[\texttt{pty} --] Establishes communication with the sub-process using a pseudo-terminal instead of a socket pair. For this to function, \texttt{openpty} or \texttt{ptmx} device is necessary.
\item[\texttt{setsid} --] Runs the command (shell) in the new session, preventing it from being affected by controlling terminal issues. Effectively, the shell stays alive even if the parent process dies.
\item[\texttt{sigint} --] Forwards \texttt{SIGINT} from the remote connection to the shell. Otherwise, sending \texttt{SIGINT} on the remote device can kill the shell session.
\item[\texttt{sane} --] With the \texttt{pty} option, it applies ``sane'' terminal settings to the \texttt{pty}.
\end{itemize}
\setlength{\leftmargini}{2.5em}


\subsection{PIP (\texttt{pip})}

\version{24.0 (python 3.12)}

\getcmdline{\commandpath{pip.txt}}{bash}{*}{mkdir,echo,pip,rm}{}{PIP reverse shell}{pip}

\TODO{dependencies}


\subsection{Tools compiled with python support}

\TODO{gdb, gimp, vim, vimdiff, rvim, view, rview}

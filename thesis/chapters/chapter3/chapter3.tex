\newcommand{\commandpath}[1]{chapters/chapter3/commands/#1}
\newcommand{\dpd}[1]{\vspace{-\baselineskip} \vspace{5pt} \begin{adjustwidth}{10pt}{0pt}\small \textbf{Dependencies:} #1 \end{adjustwidth}}
\newcommand{\notte}[1]{\vspace{-\baselineskip} \vspace{5pt} \begin{adjustwidth}{10pt}{0pt} \small \textbf{Note:} #1 \end{adjustwidth}}
\newcommand{\version}[1]{\textbf{Version:} #1}

\chapter{Methods of establishing a reverse shell}
\label{chap:methods}

This chapter explores established methods and techniques for initializing a reverse shell from a remote server. Each method is characterized by a system tool, software, or a programming language with its interpreter/compiler. We will not categorize them by what misconfiguration could cause a vulnerability that these methods could exploit, since it heavily depends on the system and what services are running on it. However, we will talk about good practices and countermeasures against reverse shell in general in the chapter <link>.

For each method, we show an actual command line example(s) of how to use the tool/software for the reverse shell, taking into account the testing environment described in the previous chapter. Furthermore, as mentioned, we list all system dependencies needed for the given method to execute successfully. If a method has excessive dependencies, such as dynamic libraries or modules, a complete list will be provided in the appendix.


\section{Network tools}

First, we list the most apparent and straightforward candidates capable of creating a reverse shell: network tools. These tools are meant for network communication and can, therefore, be used really easily if they are available to the attacker.


\subsection{NetCat (\texttt{nc}/\texttt{ncat})}

\version{7.94SVN (Nmap Project)}

NetCat is a well-known tool for reading from and writing to network connections using TCP or UDP and is preinstalled on many Linux distributions. There are multiple implementations of NetCat -- GNU's traditional implementation, OpenBSD, or the Nmap project version of NetCat called \texttt{ncat}, which we have used for testing.

Not every implementation supports the \texttt{-e} (\texttt{-{}-exec}) or \texttt{-c} (\texttt{-{}-sh-exec}) option, which causes the program to execute the given command. Option \texttt{-e} runs \texttt{exec <command>}, while \texttt{-c} executes via \texttt{/bin/sh} \cite{ncat-man}. The traditional GNU and the Nmap implementation should have this option, but the OpenBSD implementation has removed it for security reasons \cite{nc-man}.

\getcmdline{\commandpath{ncat1.txt}}{bash}{*}{ncat}{}{NetCat reverse shell (version 1, with option \texttt{-e})}{ncat1}

\notte{Standard error output of executed commands is not redirected to the socket. Option \texttt{-c} can be used instead of \texttt{-e} with the same syntax, but \texttt{/bin/sh} is needed in that case.}

However, when dealing with NetCat without the \texttt{-e} or \texttt{-c} option, the restriction can be easily bypassed by redirecting file descriptors, as shown in the \cref{lst:ncat2}. It creates a named pipe \tmp\ for connecting standard inputs and outputs of shell and NetCat processes.

\getcmdline{\commandpath{ncat2.txt}}{bash}{*}{mkfifo,ncat,rm}{}{NetCat reverse shell (version 2, with a named pipe)}{ncat2}

\dpd{\texttt{mkfifo}, \texttt{rm} (not really needed)}


\subsection{Telnet (\texttt{telnet})} \label{telnet}

\version{2.5 (GNU inetutils)}

Telnet is another popular client-server network protocol that establishes bidirectional interactive text-based communication using the TCP protocol (although now considered a legacy tool not recommended for secure communication). Unlike NetCat, Telnet does not offer a direct option to execute a command and send its output through the network. However, this limitation can be solved again by using standard Unix pipelines.

In the first example (\cref{lst:telnet1}), we use two Telnet instances. One is for receiving commands that the chosen shell will execute, and then their output will be sent through the second telnet connected to a different port (it can also be connected to a different host). The attacker needs to set up two distinct listeners accordingly.

\getcmdline{\commandpath{telnet1.txt}}{bash}{*}{telnet}{}{Telnet reverse shell (version 1, with anonymous pipes)}{telnet1}

\notte{The socket with port number \port\ serves as standard input for the shell while the socket with port number \portt\ serves as standard output and standard error output.}

Two Telnet instances were needed because anonymous Unix pipes are unidirectional. However, we can use a named pipe (like with NetCat) to create a reverse shell with only one telnet instance.

\getcmdline{\commandpath{telnet2.txt}}{bash}{*}{mkfifo,telnet,rm}{}{Telnet reverse shell (version 2, with a named pipe)}{telnet2}

\dpd{\texttt{mkfifo}, \texttt{rm}}


\subsection{Socket (\texttt{socket})}

\version{1.1}

Socket is a relatively old, lesser-known network utility for creating and interacting with sockets directly from the command line. It does not usually come preinstalled (like NetCat) on most modern distributions. It has a \texttt{-p} (\texttt{program}) option, which runs the given command for each established connection, and its standard input, standard output, and standard error channels are automatically redirected to the socket \cite{socket-man}.

\getcmdline{\commandpath{socket.txt}}{bash}{*}{socket}{}{Socket reverse shell}{socket}

\dpd{\texttt{/bin/sh} shell (\texttt{socket} executes the command specified with the \texttt{-p} option with this shell)}


\subsection{OpenSSL (\texttt{openssl})}

\version{3.0.13}

OpenSSL is a widely used toolkit that implements the SSL and TLS network protocols and related cryptography standards. It provides many commands with a variety of options and arguments, particularly for network connections between SSL/TLS clients and servers.

For the reverse shell, we will run the client on the victim's side. Since the client 'speaks' only in SSL/TLS, we need to establish a server on the attacker's side that also speaks in SSL/TLS. A simple NetCat listener will not be adequate, so we also use the \texttt{openssl} command to create a server on the attacker's side. It can be done using the following commands:

\getcmdline{\commandpath{openssl-listener.txt}}{bash}{*}{openssl}{}{Setting up an SSL/TLS server for catching OpenSSL reverse shell}{openssl-listener}

The first command generates a self-signed X.509 certificate and a new RSA 4096-bit key. Then, it saves the key and the certificate to the specified \texttt{.pem} files. The \texttt{-noenc} option makes the private key unencrypted (no password is required to access it later).

The second command runs \texttt{openssl} in server mode for listening on a specified port. The certificate and key are loaded from the \texttt{.pem} files created with the first command, and the \texttt{-quiet} option will suppress the printing of session and certificate information (recommended, but not mandatory). \cite{openssl-doc}

With the running SSL/TLS server, we can launch the client on the victim's machine and initialize the reverse shell with this command:

\getcmdline{\commandpath{openssl.txt}}{bash}{*}{mkfifo,openssl,rm}{}{OpenSSL reverse shell}{openssl}

\dpd{\texttt{mkfifo}, \texttt{rm}}

We use the same technique with named pipe as we did with NetCat or Telnet methods. Here, the \texttt{-quiet} option is neccessary. It suppresses all non-essential output (session details, certificate verification info, and other debug output), which would not be valid input for the shell interpreter and probably cause it to exit or fail unpredictably. In our tests, the connection was closed immediately when we used the command without the \texttt{-quiet} option.


\subsection{cURL (\texttt{curl})}

\version{8.5.0}

cURL ("client for URL") is a versatile tool for transferring data to or from a server using various protocols, most commonly HTTP and HTTPS. In this reverse shell scenario, we will use \texttt{curl} command to periodically make HTTP requests to an attacker's server to fetch commands via the GET method and send back their output via the POST method.

Again, we will need a special listener on the attacker's side, this time an HTTP server that will handle the request as described earlier. We provide a simple Python script that should do the work:

\getcmdline{\commandpath{curl-listener.py}}{python}{*}{}{ShellHandler,do_GET,do_POST}{Setting up custom HTTP server for catching cURL reverse shell}{curl-listener}

With the \texttt{curl} command on the victim's side, we can send the mentioned GET and POST requests together with executing fetched commands in a loop:

\getcmdline{\commandpath{curl.txt}}{bash}{*}{curl}{}{cURL reverse shell}{curl}

Option \texttt{-s} (or \texttt{-{}-silent}) is for the silent mode, which does not print show progress meter or error messages, only the HTTP response. It is needed in the first \texttt{curl} command to get just the command without auxiliary output. Option \texttt{-X} (or \texttt{-{}-request}) specifies the request method, and option \texttt{-d} (or \texttt{-{}-data}) sends the specified data in a POST request. \cite{curl-man}

It is worth mentioning that this method uses a polling-based approach, which does not require a persistent TCP connection, unlike previous methods. Apart from appearing as common web traffic (and therefore harder to detect), the loop can persist even when the attacker becomes offline, so no additional actions on the victim's machine are required if the attacker wants to obtain the reverse shell again later.


\section{Command-line interpreters}

Another straightforward way to get a reverse shell is to use shell interpreters themselves. Since some shells have built-in support for simple TCP and UDP network communication, they can be used to connect to the attacker without using other system tools. This section lists all standard and popular shells capable of creating a reverse shell alone. At the end of the section, we also mention shell interpreters that do not support this feature.

The example commands in this section follow the \texttt{\shell\ -c '\textcolor{placeholder}{$\langle$command$\rangle$}'} format, where the \texttt{-c} option tells the shell to execute the given command string. All shell interpreters support this option mentioned in this section. If you are already running an interactive session in the given shell, you can execute just the \texttt{\textcolor{placeholder}{$\langle$command$\rangle$}} portion directly. However, we use the complete form for consistency and portability, ensuring the command works regardless of the current shell environment.


\subsection{Bash (\texttt{bash})}

\version{5.2.21 (GNU)}

First on the list is the default and most commonly used shell on most Linux distributions, the Bash shell. It was designed as a free and enhanced alternative for the classic Bourne shell (sh) and other proprietary Unix shells. It also offers extensive scripting capabilities and, importantly for this context, supports TCP and UDP communication through special file descriptors located in the \texttt{/dev/tcp/} and \texttt{/dev/udp/} pseudo-filesystems.

\getcmdline{\commandpath{bash1.txt}}{bash}{*}{bash}{}{Bash reverse shell (version 1)}{bash1}

\getcmdline{\commandpath{bash2.txt}}{bash}{*}{bash}{}{Bash reverse shell (version 2)}{bash2}

\getcmdline{\commandpath{bash3.txt}}{bash}{*}{bash}{}{Bash reverse shell (version 3)}{bash3}

\dpd{\texttt{cat}}


\subsection{KornShell (\texttt{ksh}/\texttt{ksh93})}

\version{93u+m/1.0.8 (ATT)}

\getcmdline{\commandpath{ksh.txt}}{bash}{*}{ksh}{}{KornShell reverse shell}{ksh}

\notte{Support for network communication is a feature of the \texttt{ksh93} version of KornShell. The command won't work on \texttt{pdksh} shell.}


\subsection{Z shell (\texttt{zsh})}

\version{5.9}

\getcmdline{\commandpath{zsh.txt}}{bash}{*}{zsh}{}{Z shell reverse shell}{zsh}

\dpd{\texttt{zsh/net/tcp.so} \footnote{usually located somewhere in \texttt{/usr/lib/}}}


\subsection{Scheme shell (\texttt{scsh})}

\TODO{maybe remove this method}


\subsection{PowerShell (\texttt{pwsh}/\texttt{powershell})}

\version{7.5.0}

\getcmdline{\commandpath{pwsh.txt}}{bash}{*}{pwsh}{}{PowerShell reverse shell}{pwsh}

\dpd{\texttt{pwsh.dll} \footnote{usually located in \texttt{/opt/microsoft/powershell/}}, .NET}


\subsection{Shells without native network support}

In contrast to command-line interpreters that can independently establish network connections, we outline popular shells that lack this capability. Without additional programs that facilitate network communication, these shells do not inherently pose a risk of spawning a reverse shell. However, this does not suggest that other security countermeasures should be disregarded when mitigating reverse shell attack vectors.

\begin{itemize}
\item Bourne shell (\texttt{sh}) -- The standard shell for the Version 7 Unix system has been replaced by its advanced variants. Be aware that the original binary \texttt{/bin/sh} is just a link to another compatible shell on most modern Unix-like distributions.
\item Almquist shell (\texttt{ash}) and Debian Almquist shell (\texttt{dash}) -- Lightweight and POSIX-compliant shells designed for minimal environments, commonly used in embedded systems and as the default shell for Debian-based distributions.
\item C shell (\texttt{csh}) and TENEX C shell (\texttt{tcsh}) -- Shells with a syntax inspired by the C programming language. \texttt{tcsh} extends \texttt{csh} with interactive features like command-line editing and history.
\item Friendly interactive shell (\texttt{fish}) -- A user-friendly shell with advanced features like syntax highlighting, autosuggestions, and a scripting syntax distinct from POSIX-compliant shells.
\item rc shell (\texttt{rc}) -- The default shell for the Plan 9 operating system, also available on Unix systems.
\item Stand-alone shell (\texttt{sash}) -- A statically linked shell designed for system recovery and emergency maintenance.
\item Command Prompt (\texttt{cmd}) -- The default legacy command-line interpreter for Windows.
\end{itemize}


\section{Programming languages interpreters}

\subsection{Python (\texttt{python/python3})}

\version{3.12.3}

\getcmdline{\commandpath{python.txt}}{bash}{*}{python}{}{Python reverse shell}{python}

\dpd{python modules (see \cref{tab:python-dpd} in the appendix)}


\subsection{Perl (\texttt{perl})}

\version{5.38.2}

\getcmdline{\commandpath{perl.txt}}{bash}{*}{perl}{}{Perl reverse shell}{perl}

\dpd{\texttt{/dev/null}, perl modules (see \cref{tab:perl-dpd} in the appendix), loadable object \texttt{auto/Socket/Socket.so} (for module \texttt{Socket})}

\subsubsection{Comprehensive Perl Archive Network (\texttt{cpan})}

\version{Perl 5.38.2}

\getcmdline{\commandpath{cpan.txt}}{bash}{*}{echo,cpan}{}{Cpan reverse shell}{cpan}

\dpd{\texttt{perl} and its dependencies (except \texttt{/dev/null}), perl modules, loadable objects (see \cref{tab:cpan-dpd-mod,tab:cpan-dpd-so} in the appendix)}


\subsection{PHP (\texttt{php})}

\version{8.3.6}

\dpd{\texttt{UTC} file\footnote{usually located in \texttt{/usr/share/zoneinfo/}; without it, the \texttt{php} tool does not work at all}, \texttt{sh} shell (\texttt{php} uses it to execute commands in all following methods)}

\getcmdline{\commandpath{php1.txt}}{bash}{*}{php}{}{PHP reverse shell (version 1)}{php1}

\notte{\texttt{exec} function can be substituted with \texttt{shell\_exec}, \texttt{system} or \texttt{passthru} functions (they have the same argument).}

\getcmdline{\commandpath{php4.txt}}{bash}{*}{php}{}{PHP reverse shell (version 2)}{php2}

\notte{This is equivalent to calling the \texttt{shell\_exec} function as in the first method.}

\getcmdline{\commandpath{php5.txt}}{bash}{*}{php}{}{PHP reverse shell (version 3)}{php3}

\getcmdline{\commandpath{php6.txt}}{bash}{*}{php}{}{PHP reverse shell (version 4)}{php4}

\notte{This will fork the shell session without the need to use \texttt{\&}.}


\subsection{Ruby (\texttt{ruby})}

\version{3.2.3}

\getcmdline{\commandpath{ruby1.txt}}{bash}{*}{ruby}{}{Ruby reverse shell (version 1)}{ruby1}

\dpd{ruby module \texttt{socket}\footnote{usually located in \texttt{/usr/lib/ruby/<version>/}} and loadable object \texttt{socket.so}\footnote{usually located somewhere in \texttt{/usr/lib/}}}

\getcmdline{\commandpath{ruby2.txt}}{bash}{*}{ruby}{}{Ruby reverse shell (version 2)}{ruby2}

\dpd{same dependencies as the first method, \texttt{sh} shell (\texttt{popen} function uses it to execute the command)}


\subsubsection{Interactive Ruby Shell (\texttt{irb})}

\version{1.6.2}

\getcmdline{\commandpath{irb1.txt}}{bash}{*}{echo,irb}{}{IRB reverse shell (version 1)}{irb1}

\dpd{\texttt{ruby} binary\footnote{or binary \texttt{ruby<version>}, since some modules explicitly call this binary}, \texttt{/dev/null}, ruby modules, loadable objects, special gemspec files (see \cref{tab:irb-dpd-mod,tab:irb-dpd-so,tab:irb-dpd-gemspec} in the appendix)}

\getcmdline{\commandpath{irb2.txt}}{bash}{*}{echo,irb}{}{IRB reverse shell (version 2)}{irb2}

\dpd{same dependencies as the first method (\cref{lst:irb1}), \texttt{sh} shell (the same reason as with the \texttt{ruby} second method)}


\subsection{JavaScript runtime environments}

\subsubsection{Node.js (\texttt{node})}

\version{18.19.1}

\getcmdline{\commandpath{node.txt}}{bash}{*}{node}{}{Node.js reverse shell}{node}

\dpd{JavaScript modules (see \cref{tab:node-dpd} in the appendix)}


\subsubsection{Generic scripting engine (\texttt{jrunscript})}

\getcmdline{\commandpath{jrunscript.txt}}{bash}{*}{jrunscript}{}{Jrunscript reverse shell}{jrunscript}

\TODO{dependencies}


\subsubsection{Nashorn engine (\texttt{jjs})}

\version{11.0.26}

\getcmdline{\commandpath{jjs.txt}}{bash}{*}{echo,jjs}{}{JJS reverse shell}{jjs}

\TODO{dependencies}


\subsection{Julia (\texttt{julia})}

\version{1.11.4}

\getcmdline{\commandpath{julia.txt}}{bash}{^}{julia}{}{Julia reverse shell}{julia}

\dpd{dynamic libraries (see \cref{tab:julia-dpd} in the appendix), Julia module \texttt{Sockets} (files \texttt{Sockets.jl} and \texttt{Sockets/Project.toml}\footnote{usually located in \texttt{/usr/local/share/stdlib/<version>}})}


\section{Compiled programs}

So far, we have mentioned reverse shell methods that utilize one or more software tools with CLI to establish a connection back to the attacker. Another approach could be running an executable, e.g., from compiled code. In this subsection, we list methods that require compilation (not necessarily into a binary that runs the OS) before running and, therefore, cannot be executed directly from the command line.

\subsection{C (\texttt{gcc})}

\version{13.3.0}

\getcmdline{\commandpath{gcc.txt}}{C}{|}{}{main,socket,exit,htons,inet_pton,connect,close,dup2,execl}{GCC reverse shell}{gcc}

\subsection{Java (\texttt{javac})}

\version{21.0.6}

\getcmdline{\commandpath{javac.txt}}{Java}{*}{}{}{Java reverse shell}{javac}


\section{Other tools}

\subsection{Socat (\texttt{socat})}

\getcmdline{\commandpath{socat.txt}}{bash}{*}{socat}{}{Socat reverse shell}{socat}

\texttt{stderr} option redirects standard error output to the socket. Additional options can be added at the end of the command (separated by a single comma) \cite{socat-man}:

\setlength{\leftmargini}{5em}
\begin{itemize}
\item[\texttt{pty} --] Establishes communication with the sub-process using a pseudo-terminal instead of a socket pair. For this to function, \texttt{openpty} or \texttt{ptmx} device is necessary.
\item[\texttt{setsid} --] Runs the command (shell) in the new session, preventing it from being affected by controlling terminal issues. Effectively, the shell stays alive even if the parent process dies.
\item[\texttt{sigint} --] Forwards \texttt{SIGINT} from the remote connection to the shell. Otherwise, sending \texttt{SIGINT} on the remote device can kill the shell session.
\item[\texttt{sane} --] With the \texttt{pty} option, it applies ``sane'' terminal settings to the \texttt{pty}.
\end{itemize}
\setlength{\leftmargini}{2.5em}


\subsection{PIP (\texttt{pip})}

\version{24.0 (python 3.12)}

\getcmdline{\commandpath{pip.txt}}{bash}{*}{mkdir,echo,pip,rm}{}{PIP reverse shell}{pip}

\TODO{dependencies}


\subsection{Tools compiled with python support}

\TODO{gdb, gimp, vim, vimdiff, rvim, view, rview}

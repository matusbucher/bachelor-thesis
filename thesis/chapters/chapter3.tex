\chapter{Methods of establishing a reverse shell}
\label{chap:methods}

This chapter explores established methods and techniques for initializing a reverse shell from a remote server. Each method is characterized by a system tool, software, or a programming language with its interpreter/compiler. We will not categorize them by what misconfiguration could cause a vulnerability that these methods could exploit, since it heavily depends on the system and what services are running on it. However, we will talk about good practices and countermeasures against reverse shell in general in the \cref{chap:countermeasures}.

For each method, we show an actual command line example(s) of how to use the tool for the reverse shell, taking into account the testing environment described in the previous chapter. Furthermore, we list all system dependencies needed for the given method to execute successfully. If a method has excessive dependencies, such as dynamic libraries or modules, a complete list will be provided in the appendix A.


\section{Network tools}

First, we list the most apparent and straightforward candidates capable of creating a reverse shell: network tools. These tools are meant for network communication and can, therefore, be used really easily if they are available to the attacker.


\subsection{NetCat (\texttt{nc}/\texttt{ncat})}

\version{7.94SVN (Nmap Project)}

NetCat is a well-known tool for reading from and writing to network sockets using TCP or UDP and is preinstalled on many Linux distributions. There are multiple implementations of NetCat -- GNU's traditional implementation, OpenBSD, or the Nmap project version of NetCat called \texttt{ncat}, which we have used for testing.

Not every implementation supports the \texttt{-e} (or \texttt{-{}-exec}) or \texttt{-c} (or \texttt{-{}-sh-exec}) option, which causes the program to execute the given command. Option \texttt{-e} runs \texttt{exec <command>}, while \texttt{-c} executes via \texttt{/bin/sh} \cite{ncat-man}. The traditional GNU and the Nmap implementation should have this option, but the OpenBSD implementation has removed it for security reasons \cite{nc-man}.

\getcmdline{\commandpath{ncat1.txt}}{*}{ncat}{}{NetCat reverse shell (version 1, with option \texttt{-e})}{ncat1}{
\notte{Standard error output of executed commands is not redirected to the socket. Option \texttt{-c} can be used instead of \texttt{-e} with the same syntax, but \texttt{/bin/sh} is needed in that case.}
}

However, when dealing with NetCat without the \texttt{-e} or \texttt{-c} option, the restriction can be easily bypassed by redirecting file descriptors, as shown in the \cref{cmd:ncat2}. It creates a named pipe \tmp\ for connecting standard inputs and outputs of shell and NetCat processes.

\getcmdline{\commandpath{ncat2.txt}}{*}{mkfifo,ncat,rm}{}{NetCat reverse shell (version 2, with a named pipe)}{ncat2}{
\dpd{\texttt{mkfifo}}
}

\subsection{Telnet (\texttt{telnet})}
\label{sec:telnet}

\version{2.5 (GNU inetutils)}

Telnet is another popular client-server network protocol that establishes bidirectional interactive text-based communication using the TCP protocol (although now considered a legacy tool not recommended for secure communication). Unlike NetCat, Telnet does not offer a direct option to execute a command and send its output through the network. However, this limitation can be solved again by using standard Unix pipelines.

In the first example (\cref{cmd:telnet1}), we use two Telnet instances. One is for receiving commands that the chosen shell will execute, and then their output will be sent through the second telnet connected to a different port (it can also be connected to a different host). The attacker needs to set up two distinct listeners accordingly.

\newpage

\getcmdline{\commandpath{telnet1.txt}}{*}{telnet}{}{Telnet reverse shell (version 1, with anonymous pipes)}{telnet1}{
\notte{The socket with port number \port\ serves as standard input for the shell while the socket with port number \portt\ serves as standard output and standard error output.}
}

Two Telnet instances were needed because anonymous Unix pipes are unidirectional. However, we can use a named pipe (like with NetCat) to create a reverse shell with only one telnet instance.

\getcmdline{\commandpath{telnet2.txt}}{*}{mkfifo,telnet,rm}{}{Telnet reverse shell (version 2, with a named pipe)}{telnet2}{
\dpd{\texttt{mkfifo}}
}


\subsection{Socat (\texttt{socat})}

\version{1.8.0}

Socat (short for SOcket CAT) is a versatile networking tool that acts as a bidirectional data relay between two data streams, such as TCP connections, UNIX sockets, or files. It is a more complex variant of NetCat with more flexibility and a vast number of options. Thus, running a reverse shell with Socat is really simple and convenient.

Socat uses many different ``address types'' (composed of an address type keyword and an optional argument) which give instructions and the necessary information for establishing the byte streams \cite{socat-man}. We will use the \texttt{tcp:<host>:<port>} type for connecting to the remote attacker and the \texttt{exec:<command-line>}, which runs the command as a forked subprocess and connects the standard input and output to the created socket. We can add \texttt{stderr} option to the \texttt{exec} address type, so it also redirects the standard error output.

\getcmdline{\commandpath{socat.txt}}{*}{socat}{tcp,exec}{Socat reverse shell}{socat}{}

Both \texttt{tcp} and \texttt{exec} address types have multiple additional options, which can be helpful in some scenarios. They can be appended right after the address types, separated with commas and no spaces. We list only a few options for \texttt{exec} address type (apart from the used \texttt{stderr} option) \cite{socat-man}:

\setlength{\leftmargini}{5em}
\begin{itemize}
\item[\texttt{nofork}] Does not fork a subprocess for executing the program, instead calls \texttt{execvp()} or \texttt{system()} directly from the actual socat instance.
\item[\texttt{pty}] Establishes communication with the sub-process using a pseudo-terminal instead of a socket pair. For this to function, \texttt{openpty} or \texttt{ptmx} device is necessary.
\item[\texttt{sigint}] Has \texttt{socat} pass the SIGINT signal to the sub process. Otherwise, sending this signal terminates the \texttt{socat} process.
\item[\texttt{sigquit}] The same as the \texttt{sigint} option, but with the SIGQUIT signal.
\end{itemize}
\setlength{\leftmargini}{2.5em}


\subsection{Socket (\texttt{socket})}

\version{1.1}

Socket is a relatively old, lesser-known network utility for creating and interacting with sockets directly from the command line. It does not usually come preinstalled (like NetCat) on most modern distributions. It has a \texttt{-p} (\texttt{program}) option, which runs the given command for each established connection, and its standard input, standard output, and standard error channels are automatically redirected to the socket \cite{socket-man}.

\getcmdline{\commandpath{socket.txt}}{*}{socket}{}{Socket reverse shell}{socket}{
\dpd{\texttt{/bin/sh} shell (\texttt{socket} executes the command specified with the \texttt{-p} option with this shell)}
}


\subsection{OpenSSL (\texttt{openssl})}

\version{3.0.13}

OpenSSL is a widely used toolkit that implements the SSL and TLS network protocols and related cryptography standards. It provides many commands with a variety of options and arguments, particularly for network connections between SSL/TLS clients and servers.

For the reverse shell, we will run the client on the victim's side. Since the client 'speaks' only in SSL/TLS, we need to establish a server on the attacker's side that also speaks in SSL/TLS. A simple NetCat listener will not be adequate, so we also use the \texttt{openssl} command to create a server on the attacker's side. It can be done using the \cref{cmd:openssl-listener}.

\getcmdline{\commandpath{openssl-listener.txt}}{*}{openssl}{}{Setting up an SSL/TLS server for catching OpenSSL reverse shell}{openssl-listener}{}

The first command (\texttt{openssl req}) generates a self-signed X.509 certificate and a new RSA 4096-bit key. Then, it saves the key and the certificate to the specified \texttt{.pem} files. The \texttt{-noenc} option makes the private key unencrypted (no password is required to access it later).

The second command (\texttt{openssl s\_server}) runs \texttt{openssl} in server mode for listening on a specified port. The certificate and key are loaded from the \texttt{.pem} files created with the first command, and the \texttt{-quiet} option will suppress the printing of session and certificate information (recommended, but not mandatory) \cite{openssl-doc}.

With the running SSL/TLS server, we can launch the client on the victim's machine and initialize the reverse shell with the \cref{cmd:openssl}.

\getcmdline{\commandpath{openssl.txt}}{*}{mkfifo,openssl,rm}{}{OpenSSL reverse shell}{openssl}{
\dpd{\texttt{mkfifo}}
}

We use the same technique with named pipe as we did with NetCat or Telnet methods. Here, the \texttt{-quiet} option is neccessary. It suppresses all non-essential output (session details, certificate verification info, and other debug output), which would not be valid input for the shell interpreter and probably cause it to exit or fail unpredictably. In our tests, the connection was closed immediately when we used the command without the \texttt{-quiet} option.


\subsection{cURL (\texttt{curl})}

\version{8.5.0}

cURL ("client for URL") is a versatile tool for transferring data to or from a server using various protocols, most commonly HTTP and HTTPS. In this reverse shell scenario, we will use \texttt{curl} command to periodically make HTTP requests to an attacker's server to fetch commands via the GET method and send back their output via the POST method.

Again, we will need a special listener on the attacker's side, this time an HTTP server that will handle the request as described earlier. We provide a simple Python script that should do the work (\cref{code:curl-listener}).

\getcode{\commandpath{curl-listener.txt}}{python}{*}{}{ShellHandler,do_GET,do_POST}{Setting up custom HTTP server for catching cURL reverse shell}{curl-listener}{}

With the \texttt{curl} command on the victim's side, we can send the mentioned GET and POST requests together with executing fetched commands in a loop (\cref{cmd:curl}).

\getcmdline{\commandpath{curl.txt}}{*}{curl}{}{cURL reverse shell}{curl}{}

Option \texttt{-s} (or \texttt{-{}-silent}) is for the silent mode, which does not print show progress meter or error messages, only the HTTP response. It is needed in the first \texttt{curl} command to get just the command without auxiliary output. Option \texttt{-X} (or \texttt{-{}-request}) specifies the request method, and option \texttt{-d} (or \texttt{-{}-data}) sends the specified data in a POST request. \cite{curl-man}

It is worth mentioning that this method uses a polling-based approach, which does not require a persistent TCP connection, unlike previous methods. Apart from appearing as common web traffic (and therefore harder to detect), the loop can persist even when the attacker becomes offline, so no additional actions on the victim's machine are required if the attacker wants to obtain the reverse shell again later.


\section{Command-line interpreters}

Another straightforward way to get a reverse shell is to use shell interpreters themselves. Since some shells have built-in support for simple TCP and UDP network communication, they can be used to connect to the attacker without using other system tools. This section lists all standard and popular shells capable of creating a reverse shell alone. At the end of the section, we also mention shell interpreters that do not support this feature (\cref{sec:no-network-shells}).

The example commands in this section follow the \inlinecmdline{\shell\ -c '\textcolor{placeholder}{$\langle$command$\rangle$}'} format, where the \texttt{-c} option tells the shell to execute the given command string. All shell interpreters support this option mentioned in this section. If you are already running an interactive session in the given shell, you can execute just the \texttt{\textcolor{placeholder}{$\langle$command$\rangle$}} portion directly. However, we use the complete form for consistency and portability, ensuring the command works regardless of the current shell environment.


\subsection{Bash (\texttt{bash})}

\version{5.2.21 (GNU)}

First on the list is the default and most commonly used shell on most Linux distributions, the Bash shell. It was designed as a free and enhanced alternative for the classic Bourne shell (sh) and other proprietary Unix shells \cite{gnu-about}. It also offers extensive scripting capabilities and, importantly for this context, supports TCP and UDP communication through special file descriptors located in the \texttt{/dev/tcp/} and \texttt{/dev/udp/} pseudo-filesystems.

Bash treats these pseudo-file paths semantically like regular files, which allows standard input and output redirection to be used with them. This makes establishing a reverse shell connection possible using simple redirection syntax.

\getcmdline{\commandpath{bash.txt}}{*}{bash}{}{Bash reverse shell}{bash}{}


\subsection{Korn shell (\texttt{ksh}/\texttt{ksh93}/\texttt{rksh}/\texttt{rksh93})}

\version{93u+m/1.0.8 (ATT)}

Korn shell is a shell developed by David Korn as a successor to the Bourne shell. It was originally proprietary software, which led to the creation of several free and open-source alternatives, including Bash. There are actually many versions and clones of Korn shell, like \texttt{pdksh}, \texttt{mksh} and others, while the original is \texttt{ksh88}.

However, the version that added support for network communication is the newer \texttt{ksh93} version. It is realized through the same \texttt{/dev/tcp/} and \texttt{/dev/udp/} pseudo-filesystems as with Bash. Creation of reverse shell is thus done exactly as in the \cref{cmd:bash}.

\getcmdline{\commandpath{ksh.txt}}{*}{ksh}{}{Korn shell reverse shell}{ksh}{}

Additionally, there are two other clones of \texttt{ksh93} which also support this feature -- \texttt{dtksh} (Desktop Korn shell, a fork included as part of CDE) and \texttt{tksh} (a fork that provides access to the Tk widget toolkit) \cite{kornshell-wiki}. The Korn shell variants, which do not have networking features, are listed at the end of the section (\cref{sec:no-network-shells}).

\subsection{Z shell (\texttt{zsh})}

\version{5.9}

Z shell is a feature-rich Unix shell offering advanced scripting capabilities and customization options. It is the default login shell on macOS and Kali Linux. Unlike Bash or Korn shell, Z shell does not support the \texttt{/dev/tcp/} or \texttt{/dev/udp/} pseudo-filesystems. Instead, additional features of the Z shell, including networking, are in modules, separate from the shell's core. Each module may be linked into the shell at build time or dynamically linked while the shell is running. \cite{zshmodules-man}

The module \texttt{zsh/net/tcp}, which provides manipulation of TCP sockets, can be loaded with the \texttt{zmodload} keyword. With the module loaded, we can run the \texttt{ztcp} command, which opens a new TCP connection to the specified host and port. The argument of option \texttt{-d} will be taken as the target file descriptor for the connection \cite{zsh-net-tcp-doc}. We can then redirect the standard input and output of the new shell session to this file descriptor.

\getcmdline{\commandpath{zsh.txt}}{*}{zsh}{}{Z shell reverse shell}{zsh}{
\dpd{\texttt{zsh/net/tcp.so} \footnote{usually located somewhere in \texttt{/usr/lib/}}}
}


\subsection{PowerShell (\texttt{pwsh}/\texttt{powershell})}

\version{7.5.0}

PowerShell is a powerful shell and scripting language developed by Microsoft. Unlike traditional shells, it is object-oriented. PowerShell comes preinstalled on modern Windows systems, but additionally, an open-source, cross-platform version -- \texttt{pwsh} -- is available for Linux and macOS. The following method is compatible on all platforms.

Reverse shell via PowerShell is more complicated than previous shells. To work with network connections, it requires using .NET classes and managing multiple objects such as sockets, streams, and others. Hence, we will need a PowerShell script rather than a simple command with redirections (this makes this method closer to the ``programming language interpreters'' category -- \cref{sec:program-interpreters}). Nevertheless, it can still be made into a one-liner using the \texttt{-c} (or \texttt{-Command}) option and separating lines from the script with a semicolon (see \cref{cmd:pwsh-oneline}).

\getcode{\commandpath{pwsh-script.txt}}{bash}{*}{}{}{PowerShell reverse shell script}{pwsh-script}{
\dpd{\texttt{pwsh.dll} \footnote{usually located in \texttt{/opt/microsoft/powershell/}}, .NET}
}

To run the script saved as \scriptfile , execute the \texttt{pwsh} command with the option \texttt{-f} (or \texttt{-File}).

\getcmdline{\commandpath{pwsh-runscript.txt}}{*}{pwsh}{}{Running the PowerShell reverse shell script}{pwsh-runscript}{}

As mentioned, we can execute the PowerShell script as a one-line command by using the \texttt{-c} option.

\getcmdline{\commandpath{pwsh-oneline.txt}}{*}{pwsh}{}{PowerShell one-line reverse shell}{pwsh-oneline}{}


\subsection{Tcl shell (\texttt{tclsh})}

\version{8.6.14}

Tcl (Tool Command Language) is a lightweight scripting language designed to be simple and powerful. It comes with an interactive shell called \texttt{tclsh} \cite{tclsh-man}. The shell provides access to Tcl's core language features, including I/O, string processing, and networking.

Creating a reverse shell in Tcl is relatively straightforward compared to PowerShell (\cref{code:pwsh-script}), thanks to its built-in \texttt{socket} command and dynamic evaluation capabilities. However, since Tcl lacks built-in redirection operators like POSIX shells, error handling and stream management must be implemented manually within the script logic. Again, we provide the script and show how it can be run from a file or as a one-line command.

\getcode{\commandpath{tclsh-script.txt}}{bash}{*}{}{}{Tcl reverse shell script}{tclsh-script}{
\dpd{environment variable \texttt{TCL\_LIBRARY} set to Tcl installation directory\footnote{usually \texttt{/usr/share/tcltk/tcl<version>/}}, Tcl library \texttt{init.tcl}\footnote{located in \texttt{\$TCL\_LIBRARY}}}
}

\getcmdline{\commandpath{tclsh-runscript.txt}}{*}{tclsh}{}{Running the Tcl reverse shell script}{tclsh-runscript}{}


\getcmdline{\commandpath{tclsh-oneline.txt}}{*}{tclsh,echo}{}{Tcl one-line reverse shell}{tclsh-oneline}{}


\subsection{Shells without native network support}
\label{sec:no-network-shells}

In contrast to command-line interpreters that can independently establish network connections, we outline popular shells that lack this capability \cite{shell-comparison-wiki}. Without additional programs that facilitate network communication, these shells do not inherently pose a risk of spawning a reverse shell. However, this does not suggest that other security countermeasures should be disregarded when mitigating reverse shell attack vectors.

\begin{itemize}

\item \textbf{Bourne shell} (\texttt{sh}) -- The standard shell for the Version 7 Unix system; has been replaced by its advanced variants. Be aware that the original binary \texttt{/bin/sh} is just a link to another compatible shell on most modern Unix-like distributions.

\item \textbf{Almquist shell} (\texttt{ash}) and \textbf{Debian Almquist shell} (\texttt{dash}) -- Lightweight and POSIX-compliant shells designed for minimal environments, commonly used in embedded systems and as the default shell for Debian-based distributions.

\item The original Korn shell (\texttt{ksh88}), \textbf{Public domain Korn shell} (\texttt{pdksh}), \textbf{MirBSD Korn shell} (\texttt{mksh}), \textbf{Portable OpenBSD Kown shell} (\texttt{oksh}) and other variants and forks not based on \texttt{ksh93}.

\item \textbf{C shell} (\texttt{csh}) and \textbf{TENEX C shell} (\texttt{tcsh}) -- Shells with a syntax inspired by the C programming language. \texttt{tcsh} extends \texttt{csh} with interactive features like command-line editing and history.

\item \textbf{Friendly interactive shell} (\texttt{fish}) -- A user-friendly shell with advanced features like syntax highlighting, autosuggestions, and a scripting syntax distinct from POSIX-compliant shells.

\item \textbf{rc shell} (\texttt{rc}) -- The default shell for the Plan 9 operating system, also available on Unix systems.

\item \textbf{Stand-alone shell} (\texttt{sash}) -- A statically linked shell designed for system recovery and emergency maintenance.

\item \textbf{Command Prompt} (\texttt{cmd}) -- The default legacy command-line interpreter for Windows.

\end{itemize}


\section{Programming language interpreters}
\label{sec:program-interpreters}

In this section, we cover common interpreted programming or scripting languages. Every proper programming language should be capable of opening a TCP socket for network communication (perhaps with some standard module), running a command from the operating system, redirecting standard file descriptors to the socket -- and, therefore, creating a reverse shell. The interesting part is which dynamic libraries and modules are requisite for each method.

Almost all examples in this section are written as script files, but, as with the PowerShell example (\cref{code:pwsh-script}), they can easily be turned into one-liners with specific options or pipelines. We will specify how to do this for each method. The example scripts also include comments with decent explanations of what the script does.


\subsection{Python (\texttt{python/python3})}

\version{3.12.3}

Python is one of the most popular programming languages, known for its simple, readable syntax and vast standard library. Among the example scripts in this section, the following one for Python reverse shell is relatively short and straightforward. It also requires a small number of Python modules.

\getcode{\commandpath{python-script.txt}}{python}{*}{}{}{Python reverse shell script}{python-script}{
\dpd{Python modules (see \cref{tab:python-dpd} in the appendix A)}
}

The \texttt{os.execvp()} call can be replaced with any other function from the ``exec family''\footnote{\texttt{execv}, \texttt{execvp}, \texttt{execve}, \texttt{execvpe}}, or with other functions that spawn subprocesses, such as \texttt{os.system()}, functions from the \texttt{subprocess} module (\texttt{subprocess.run()}, \texttt{subprocess.call()}, etc.), or \texttt{pty.spawn()} from the \texttt{pty} module, which emulates a more stable interactive terminal. Naturally, using functions from additional modules introduces dependencies on external Python modules or other libraries.

\getcmdline{\commandpath{python-runscript.txt}}{*}{python}{}{Running the Python reverse shell script}{python-runscript}{}

Now, the script can be turned into a one-liner using Python's \texttt{-c} option and separating lines with semicolons \cite{python-man}. The for loop, however, must be compressed to a list comprehension as \inlinecmdline{[os.dup2(sock.fileno(),fd) for fd in (0,1,2)]} or expanded into three separate lines (one for each file descriptor).

\getcmdline{\commandpath{python-oneline.txt}}{*}{python}{}{Python one-line reverse shell}{python-oneline}{}


\subsubsection{Pip (\texttt{pip})}

\version{24.0 (python 3.12)}

Pip is the default package manager for Python, used to install and manage third-party libraries from the Python Package Index (PyPI). Most distributions of Python come with the \texttt{pip} tool preinstalled. While primarily intended for managing dependencies in software projects, Pip can be misused to execute arbitrary Python code during package installation via a specially crafted \texttt{setup.py} script. This file should contain the package's metadata and installation instructions, and Pip automatically searches for it and executes it to build and install the package \cite{pip-install-doc}.

So, we can use the Python script for reverse shell (see \cref{code:python-script}) as the \texttt{setup.py} file, and then give the directory in which this file is as the argument to the \texttt{pip install} command. For clarity and a general case, we use a temporary directory \tmp\ to place the custom \texttt{setup.py} file.

\getcmdline{\commandpath{pip.txt}}{*}{mkdir,echo,pip,rm}{}{Pip reverse shell}{pip}{
\dpd{dependencies from \cref{code:python-script}, additional Python modules and loadable objects (see \cref{tab:pip-dpd-mod} and \cref{tab:pip-dpd-so} in the appendix A)}
}

We need to use the \texttt{-{}-break-system-packages} option in case of the externally managed environment \cite{pip-install-doc}. That is when the Python installation is marked as ``externally managed'' by the OS package manager (like \texttt{apt}) and the \texttt{pip} tool is about to install packages ``system-wide'', which could overwrite system-managed Python packages (and thus break some functionality that depends on those packages). We are not overwriting any system packages in our case, but it is an additional security permission that the \texttt{pip} tool requires.


\subsection{Perl (\texttt{perl})}

\version{5.38.2}

Perl is a high-level language designed as a general-purpose Unix scripting language to facilitate report processing. Although less commonly used today than Python or other scripting languages, Perl remains a staple in many legacy systems. The script for the reverse shell is, again, really straightforward, with a few dependent modules.

\getcode{\commandpath{perl-script.txt}}{perl}{*}{}{}{Perl reverse shell script}{perl-script}{
\dpd{\texttt{/dev/null}, Perl modules (see \cref{tab:perl-dpd} in the appendix A), loadable object \texttt{auto/Socket/Socket.so} (for module \texttt{Socket})}
}

\getcmdline{\commandpath{perl-runscript.txt}}{*}{perl}{}{Running the Perl reverse shell script}{perl-runscript}{}

To make it into a one-line command, use the \texttt{-e} (or \texttt{-E}) option with the compressed script \cite{perl-man}.

\getcmdline{\commandpath{perl-oneline.txt}}{*}{perl}{}{Perl one-line reverse shell}{perl-oneline}{}

\subsubsection{Comprehensive Perl Archive Network (\texttt{cpan})}
\label{sec:cpan}

\version{Perl 5.38.2}

CPAN is a large repository of Perl modules and libraries. It is typically accessed using the \texttt{cpan} command-line tool, which allows users to search for, install, and manage Perl modules directly from the terminal. When run without arguments, the tool starts an interactive CPAN session, where the exclamation mark (\texttt{!}) executes arbitrary commands. While this feature is intended to allow running shell commands (such as \inlinecmdline{! ls}), it can also interpret and execute valid Perl code \cite{cpan-man}.

Hence, we could start the \texttt{cpan} session and enter the compressed Perl code from \cref{code:perl-script} prefixed with \texttt{!}. We can also pass the line to \texttt{cpan} through a pipeline with the \texttt{echo} command, as shown below.

\getcmdline{\commandpath{cpan-oneline.txt}}{*}{echo,cpan}{}{Cpan one-line reverse shell}{cpan-oneline}{
\dpd{\texttt{perl}, dependencies from \cref{code:perl-script} (except \texttt{/dev/null}), additional Perl modules and loadable objects (see \cref{tab:cpan-dpd-mod,tab:cpan-dpd-so} in the appendix A)}
}


\subsection{PHP (\texttt{php})}

\version{8.3.6}

PHP is a widely used server-side scripting language. It is primarily designed for web development but capable of general-purpose scripting. It has built-in networking and process control functions, allowing quick and effective reverse shell implementations. That makes PHP reverse shell especially useful in web-based attack scenarios like file upload or remote code execution vulnerabilities.

Our minimal example of a PHP reverse shell consists of only two function calls. Since these functions are part of PHP's core, loading additional modules is not required (which makes the dependency list minimalistic).

\getcode{\commandpath{php-script.txt}}{php}{*}{}{}{PHP reverse shell script}{php-script}{
\dpd{\texttt{UTC} file\footnote{usually located in \texttt{/usr/share/zoneinfo/}; without it, the \texttt{php} tool does not work at all}, \texttt{sh} shell (\texttt{php} uses it to execute commands)}
\notte{This will fork the shell session without the need to use \texttt{\&} in the command passed to the \texttt{proc\_open()} function.}
}

We can use the option \texttt{-f} (or \texttt{--file}) to execute the script (but it also works without the option, when we pass the filename as the only argument).

\getcmdline{\commandpath{php-runscript.txt}}{*}{php}{}{Running the PHP reverse shell script}{php-runscript}{}

The option \texttt{-r} (or \texttt{-{}-run}) of the PHP command line tool allows us to run the code as one command \cite{php-man}. However, we must omit the PHP opening and closing tags (\texttt{<?php} and \texttt{?>}) in the compressed script.

\getcmdline{\commandpath{php-oneline.txt}}{*}{php}{}{PHP one-line reverse shell}{php-oneline}{}

Additionally, the \texttt{proc\_open()} call can be substituted with other functions that accept only the command argument without the descriptor specification. This can be fixed using standard shell redirections as part of the command passed to the function. The \texttt{fsockopen()} call assigns the first available file descriptor number to the opened socket, which we can use for the shell redirections. However, this number differs when executing the script from a file or with the \texttt{-r} option from the command line. In the first case (\cref{cmd:php-runscript}), the assigned file descriptor should be number 4, while in the second case (\cref{cmd:php-oneline}) it should be number 3\footnote{we have not investigated further why this is so, we have identified the numbers just from testing}. We will refer to this number as \fd.

Also, be aware that the \texttt{\$sock} variable (to which the return value of \texttt{fsockopen()} call is assigned) is still needed even with the substituted functions, which do not directly use this variable, because otherwise the socket would be closed immediately by PHP garbage collection. Finally, these are the functions that can be used instead of \texttt{proc\_open()} one:

\begin{itemize}

\item \inlinecmdline{exec("\shell\ <\&\fd\ >\&\fd\ 2>\&\fd ")}
\item \inlinecmdline{system("\shell\ <\&\fd\ >\&\fd\ 2>\&\fd ")}
\item \inlinecmdline{shell\_exec("\shell\ <\&\fd\ >\&\fd\ 2>\&\fd ")} or \\ \inlinecmdline{`\shell\ <\&\fd\ >\&\fd\ 2>\&\fd `} (with the backtick symbols) -- these are semantically equivalent
\item \inlinecmdline{passthru("\shell\ <\&\fd\ >\&\fd\ 2>\&\fd ")}
\item \inlinecmdline{popen("\shell\ <\&\fd\ >\&\fd\ 2>\&\fd ", "r")}

\end{itemize}


\subsection{Lua (\texttt{lua})}

\version{5.3.6}

Lua is a lightweight, embeddable scripting language designed primarily for integration into other applications. It is widely used in game development, embedded systems, and configuration scripting. The LuaRocks package manager (\texttt{luarocks}) allows users to extend the language's minimal core by installing additional packages.

We need the \texttt{socket} library for a reverse shell from the \texttt{luasocket} package. To install it, we issue:

\begin{cmdline}{*}{luarocks}{}
luarocks install luasocket
\end{cmdline}

However, the following script depends on only two files from the package (see \textbf{Dependencies}).

\getcode{\commandpath{lua-script.txt}}{[5.0]Lua}{*}{}{}{Lua reverse shell script}{lua-script}{
\dpd{\texttt{sh} shell (\texttt{os.execute()} uses it to execute the command), Lua \texttt{socket} module\footnote{\texttt{.lua} file, usually located in \texttt{/usr/share/lua/<version>/}} and loadable object \texttt{socket/core.so}\footnote{usually located somewhere in \texttt{/usr/lib/} under \texttt{lua/<version>} directory}}
}

\getcmdline{\commandpath{lua-runscript.txt}}{*}{lua}{}{Running the Lua reverse shell script}{lua-runscript}{}

Another option, though kind of redundant, is compiling the Lua code with \texttt{luac} compiler and then running the compiled code with \texttt{lua} interpreter. We can also run the script directly from the command line using Lua's \texttt{-e} option.

\getcmdline{\commandpath{lua-oneline.txt}}{*}{lua}{}{Lua one-line reverse shell}{lua-oneline}{}


\subsection{Ruby (\texttt{ruby})}

\version{3.2.3}

Ruby is a dynamic, object-oriented programming language known for its clean syntax and focus on developer productivity. It is widely used in web development (notably with Ruby on Rails, a server-side web application framework) but functions well as a general-purpose scripting language.

The simplicity of the Ruby language makes the reverse shell script again pretty straightforward. We present two fundamentally different versions -- the first redirects standard file descriptors and replaces the process with the given shell; the second reads commands from the socket, executes them with the \texttt{sh} shell, and sends the output back to the socket in a loop. Both scripts require only one module.

\getcode{\commandpath{ruby-script1.txt}}{ruby}{*}{}{}{Ruby reverse shell script (version 1)}{ruby-script1}{
\dpd{Ruby module \texttt{socket}\footnote{\texttt{.rb} file, usually located in \texttt{/usr/lib/ruby/<version>/}} and loadable object \texttt{socket.so}\footnote{usually located somewhere in \texttt{/usr/lib/} under \texttt{ruby/<version>} directory}}
}

\getcode{\commandpath{ruby-script2.txt}}{ruby}{*}{}{}{Ruby reverse shell script (version 2)}{ruby-script2}{
\dpd{same dependencies from \cref{code:ruby-script1}, \texttt{sh} shell (\texttt{popen()} function uses it to execute the command)}
}

\getcmdline{\commandpath{ruby-runscript.txt}}{*}{ruby}{}{Running the Ruby reverse shell script}{ruby-runscript}{}

The \texttt{ruby} tool supports option \texttt{-e}, which can turn the scripts into one-line commands \cite{ruby-man}.

\getcmdline{\commandpath{ruby-oneline.txt}}{*}{ruby}{}{Ruby one-line reverse shell}{ruby-oneline}{}


\subsubsection{Interactive Ruby Shell (\texttt{irb})}

\version{1.6.2}

Ruby also comes with an interactive shell called IRB (Interactive Ruby), which allows users to execute Ruby code line by line directly from the terminal. Similarly to the \texttt{cpan} (\cref{sec:cpan}) tool, we can pass the compressed script (either \cref{code:ruby-script1} or \cref{code:ruby-script2}) to the \texttt{irb} through a pipeline.

\getcmdline{\commandpath{irb-oneline.txt}}{*}{echo,irb}{}{IRB one-line reverse shell}{irb-oneline}{
\dpd{\texttt{ruby} \footnote{or \texttt{ruby<version>}, since some modules explicitly call this binary}, dependencies from either \cref{code:ruby-script1}\ or \cref{code:ruby-script2}, \texttt{/dev/null}, additional Ruby modules, loadable objects and special gemspec files (see \cref{tab:irb-dpd-mod,tab:irb-dpd-so,tab:irb-dpd-gemspec} in the appendix A)}
}


\subsection{JavaScript runtime environments}

JavaScript is one of the most popular scripting languages. It is traditionally associated with web browsers as a client-side scripting language, but it can also be executed outside of browsers using various runtime environments. At the core of these environments are JavaScript engines --- programs that parse and execute JavaScript code \cite{js-engines-wiki}. Our analysis focuses on two JavaScript runtime environments: Node.js and Nashorn. For each one of the two, we mention what command line tool is used for the execution of code in these environments (either from a script file or as a one-liner).

\subsubsection{Node.js (\texttt{node})}

\version{18.19.1}

Node.js is a popular standalone server-side runtime built on the V8 engine and can be invoked with the \texttt{node} command \cite{nodejs-doc}. It has built-in modules, such as \texttt{net} and \texttt{child\_process} for networking and process management. The implementation is, therefore, relatively simple (at least more simple than with the Nashorn).

\getcode{\commandpath{node-script.txt}}{java}{*}{}{}{Node.js reverse shell script (JavaScript)}{node-script}{
\dpd{JavaScript modules (see \cref{tab:node-dpd} in the appendix A)}
}

\getcmdline{\commandpath{node-runscript.txt}}{*}{node}{}{Running the Node.js reverse shell script}{node-runscript}{}

The option \texttt{-e} (or \texttt{-{}-eval}) serves for execution of code directly from the command line.

\getcmdline{\commandpath{node-oneline.txt}}{*}{node}{}{Node.js one-line reverse shell}{node-oneline}{}


\subsubsection{Nashorn engine (\texttt{jjs})}

\version{1.8.0\_452}

Nashorn is a Java-based JavaScript runtime included with Java 8 up to the JDK 14 and is now marked as depreciated \cite{nashorn-dep}. It runs on the Java Virtual Machine (JVM) and provides Java interoperability. Nashorn scripts can be executed using the \texttt{jjs} command line tool \cite{nashorn-doc}.

Nashorn relies on Java classes like \texttt{java.net.Socket} and \texttt{ProcessBuilder}, which makes the code similar to Java code discussed later (\cref{code:java-code}).

\getcode{\commandpath{nashorn-script.txt}}{java}{*}{}{}{Nashorn engine reverse shell script (JavaScript)}{nashorn-script}{
\dpd{environment variable \texttt{JAVA\_HOME} set to Java installation directory\footnote{usually \texttt{/usr/lib/jvm/java-<JDK-version>-openjdk-<architecture>/}}, system's dynamic libraries and Java's special dynamic libraries (see \cref{tab:nashorn-dpd} in the appendix A), JVM configuration file \texttt{jvm.cfg}\footnote{located in \texttt{\$JAVA\_HOME/lib/}}, \texttt{rt.jar} and \texttt{ext/nashorn.jar} Java archive files\footnote{packages that bundle multiple Java class files, located in \texttt{\$JAVA\_HOME/lib/}} and data file \texttt{tzdb.dat}\footnote{time zone database, located in \texttt{\$JAVA\_HOME/lib/}}}
}

\getcmdline{\commandpath{jjs-runscript.txt}}{*}{jjs}{}{Running the Nashorn reverse shell script using jjs}{jjs-runscript}{}

The \texttt{jjs} tool does not offer the option to pass the script as a string, but we can achieve the goal by piping the compressed script to \texttt{jjs} interactive mode.

\getcmdline{\commandpath{jjs-oneline.txt}}{*}{echo,jjs}{}{jjs one-line reverse shell}{jjs-oneline}{}


\subsection{Julia (\texttt{julia})}

\version{1.11.4}

Julia is a high-level, high-performance programming language designed primarily for numerical and scientific computing \cite{julia-intro}. It combines the flexibility of dynamic languages with the speed of compiled languages through just-in-time (JIT) compilation. Julia typically runs like a scripting language through its interactive runtime, but it also supports packaging code into standalone binaries \cite{julia-compiler}. Additionally, Julia excels in interoperability -- it can call libraries written in languages like C or Rust, and Julia packages themselves can be accessed from languages like Python or R \cite{julia-calling-c}.

Naturally, Julia provides socket programming functionality, making it capable of creating a reverse shell.

\getcode{\commandpath{julia-script.txt}}{perl}{^}{}{}{Julia reverse shell script}{julia-script}{
\dpd{dynamic libraries (see \cref{tab:julia-dpd} in the appendix A), Julia module \texttt{Sockets} (files \texttt{Sockets.jl} and \texttt{Sockets/Project.toml}\footnote{usually located in \texttt{/usr/local/share/stdlib/<version>}})}
}

\getcmdline{\commandpath{julia-runscript.txt}}{*}{julia}{}{Running the Julia reverse shell script}{julia-runscript}{}

Jullia command-line interface comes with the option \texttt{-e} (or \texttt{-{}-eval}), which can evaluates the compressed reverse shell script.

\getcmdline{\commandpath{julia-oneline.txt}}{*}{julia}{}{Julia one-line reverse shell}{julia-oneline}{}


\section{Compiled programs}
\label{sec:program-compilers}

So far, we have mentioned reverse shell methods that utilize one or more software tools with a CLI to establish a connection back to the attacker. Another approach is running an executable from compiled code. In this subsection, we list methods that require compilation (not necessarily into machine code, see \cref{sec:java}) before running and, therefore, cannot be executed directly from the command line. We will focus on one specific compiler for each considered language, since analyzing dependencies for each available compiler would be complicated and is beyond the scope of this thesis.

\subsection{C/C++ (\texttt{gcc})}
\label{sec:gcc}

\version{13.3.0}

First on the list are the classic C and C++ (since all C code is valid C++ code) and the \texttt{gcc} (GNU Compiler Collection) compiler. Although any C compiler can be used to compile the example code, dependencies have been analysed only for the \texttt{gcc} compiler (version 13).

C is a low-level, system-oriented language that provides direct access to memory and system calls. Many tools mentioned in this thesis are themselves implemented in C. However, the low-level nature of the language means that the code is not as clean as with other high-level languages. The basic explanation of the code can be found in the comments.

\getcode{\commandpath{c-code.txt}}{C}{|}{}{}{C/C++ reverse shell code}{c-code}{}

Just as shown in the PHP example (see \cref{code:php-script}), the \texttt{execl()} function, which replaces the process with a shell, can be substituted with other similar functions. Alternatives include \texttt{execve()} (a system call which is essentially called by the other functions), \texttt{execlp()}, \texttt{execvp()}, \texttt{system()}, or \texttt{popen}. Each of these functions has slightly different syntax and may introduce different dependencies or behaviors -- for example, \texttt{system()} requires access to \texttt{/bin/sh}, while \texttt{execvp()} searches the \texttt{PATH} environment variable.

We show how the code can be compiled in the simplest way.

\getcmdline{\commandpath{c-runcode.txt}}{*}{gcc}{}{Compiling and running the C/C++ reverse shell code}{c-runcode}{
\dpd{\texttt{as} (GNU assembler), \texttt{ld} (GNU linker), \texttt{cc1}\footnote{component of \texttt{gcc} that compiles source code to assembly, usually located in \texttt{/usr/libexec/gcc/<architecture>/<gcc-version>}}, static and dynamic libraries and header files (see \cref{tab:c-dpd-lib} and \cref{tab:c-dpd-include} in the appendix A)}
\notte{The \texttt{-o} option can be omitted -- in that case, the created binary will have the default \texttt{a.out} file name \cite{gcc-man}.}
}

The GCC compiler offers plentiful options. Perhaps the most interesting ones are these \cite{gcc-man}:

\setlength{\leftmargini}{5em}
\begin{itemize}
\item[\texttt{-static}] Links the libraries statically, producing a self-contained binary that does not depend on shared libraries at runtime, but takes more space.
\item[\texttt{-Os}] Optimize for smaller size.
\item[\texttt{-s}] Strips the symbol table and relocation information from the executable, making the final binary smaller.
\end{itemize}
\setlength{\leftmargini}{2.5em}


\subsection{Java (\texttt{javac})}
\label{sec:java}

\version{21.0.7}

Another popular compiled language is Java, using the official \texttt{javac} compiler from the Java Development Kit (JDK). Java is a high-level, object-oriented programming language designed for portability and cross-platform compatibility. Unlike C/C++, Java code is compiled into bytecode class files rather than native machine code. The bytecode is then executed by the Java Virtual Machine (JVM), which serves as an abstraction layer between the compiled program and the underlying operating system \cite{javac-doc} and is typically invoked using the \texttt{java} command (see \cref{cmd:java-runcode}). We used the relatively recent \texttt{javac} version 21 for our analysis.

Moving to the source code, Java uses stream objects as an abstraction over file descriptors. We need a pair of streams -- input and output -- for both the socket and the shell process. It might be counterintuitive, but the input streams correspond to standard outputs, and the output streams to standard inputs (the names are from the perspective of the Java program). The redirection must be handled manually using a while loop since there is no Java API to directly pipe a process's input and output to a socket\footnote{The \texttt{ProcessBuilder} class does provide \texttt{redirectInput} and \texttt{redirectOutput} methods, but they only accept files as arguments \cite{processbuilder-doc}}. The loop continuously checks whether data is available to read from either side and forwards it to the other end. This minimal approach avoids using threads or additional I/O helpers, keeping the implementation simple.

\getcode{\commandpath{java-code.txt}}{Java}{*}{}{}{Java reverse shell code}{java-code}{}

\getcmdline{\commandpath{java-runcode.txt}}{*}{javac,java}{}{Compiling and running the Java reverse shell code}{java-runcode}{
\dpd{environment variable \texttt{JAVA\_HOME} set to Java installation directory\footnote{usually \texttt{/usr/lib/jvm/java-<JDK-version>-openjdk-<architecture>/}}, system's dynamic libraries and Java's special dynamic libraries (see \cref{tab:java-dpd} in the appendix A), JVM configuration file \texttt{jvm.cfg}\footnote{located in \texttt{\$JAVA\_HOME/lib/}}, \texttt{jspawnhelper} executable\footnote{used internally by the JVM to spawn child processes, located in \texttt{\$JAVA\_HOME/lib/}} and Java module image \texttt{modules}\footnote{binary archive that contains all modularized Java runtime classes, located in \texttt{\$JAVA\_HOME/lib/}}}
}


\subsection{Golang (\texttt{go})}

\version{1.22.2}

Next is Golang (or Go), which is a modern, statically typed, and compiled programming language developed at Google. Although syntactically similar to C, it has high-level features like memory safety, garbage collection, and CSP-style concurrency \cite{go-doc}. It is also known for its simplicity of syntax and efficiency.

Go compiles code into a machine code binary. There is an official Go compiler, which we also used for testing, but other less-used alternatives exist. Command \texttt{go run} compiles the code and also executes it (\texttt{go build} command is used solely for compiling the code).

\getcode{\commandpath{go-code.txt}}{Golang}{*}{}{}{Go reverse shell code}{go-code}{}

There are also some interesting compilation options:

\setlength{\leftmargini}{10em}
\begin{itemize}
\item[\texttt{CGO\_ENABLED=0}] Makes the binary statically linked (without any external dependencies during runtime).
\item[\texttt{-ldflags="-s -w"}] Makes the binary smaller by striping the symbol table and debug info (same as option \texttt{-s} of \texttt{gcc} compiler, see \cref{sec:gcc}).
\item[\texttt{GOOS}/\texttt{GOARCH}] Lets you generate binaries for any OS/architecture. For example
\begin{cmdline}{*}{go}{}
GOOS=windows GOARCH=amd64 go build *\codefile* -o *\tmp*
\end{cmdline}
\end{itemize}
\setlength{\leftmargini}{2.5em}

\getcmdline{\commandpath{go-runcode.txt}}{*}{go}{}{Compiling and running the Go reverse shell code}{go-runcode}{
\dpd{\texttt{/dev/null}, environment variable \texttt{GOROOT} set to Golang installation directory\footnote{usually \texttt{/urs/local/go} or \texttt{/urs/lib/go}}, Golang tools\footnote{usually located in \texttt{\$GOROOT/pkg/tool/<architecture>/}} \texttt{asm}, \texttt{compile} and \texttt{link}, header files\footnote{usually located in \texttt{\$GOROOT/pkg/include/}}	\texttt{asm\_amd64.h}, \texttt{funcdata.h} and \texttt{textflag.h}, Golang modules (see \cref{tab:go-dpd} in the appendix A)}
}


\section{Other tools}

\subsection{Gawk (\texttt{gawk})}

\version{GNU Awk 5.2.1}

AWK is a text-processing and pattern-scanning language commonly used in Unix-like systems for data manipulation tasks. Initially developed to work with textual data stored in files, it was never meant for networking purposes \cite{gawk-doc}.

Its GNU implementation, gawk, extends the standard AWK features with more powerful capabilities, including built-in support for network communication. Specifically, gawk allows the use of special file names in the form of

\qquad \texttt{/net-type/protocol/localport/hostname/remoteport}

together with the \texttt{|\&} coprocess operator for creating TCP/IP network connections \cite{gawk-man}. We will provide the example in the form of an AWK script, as we did in the previous sections, but it can be executed directly from the command line.

\getcode{\commandpath{gawk-script.txt}}{awk}{*}{}{}{Gawk reverse shell script}{gawk-script}{}

Since the gawk's coprocess feature (the \texttt{|\&} operator) captures only the standard output of the command, while the coprocess's standard error goes to the same place as gawk's standard error \cite{gawk-io}. So we need to explicitly redirect it to standard output within the command string itself. This was done by appending \texttt{2>\&1} to the command \texttt{c}.

It is also vital to close the command's streams after execution because each shell command that the attacker runs through the reverse shell is associated with a separate process (or opened file). If you attempt to execute the same command again without closing the previous instance, gawk will reuse the existing process, which could lead to unexpected results \cite{gawk-close}. Closing the coprocess also saves system resources.

Next, we show how to run the script file (option \texttt{-f} or \texttt{--file}) or execute the script from the command line.

\getcmdline{\commandpath{gawk-runscript.txt}}{*}{gawk}{}{Running the Gawk reverse shell script}{gawk-runscript}{}

\getcmdline{\commandpath{gawk-oneline.txt}}{*}{gawk}{}{Gawk one-line reverse}{gawk-oneline}{}


\subsection{GNU Debugger (\texttt{gdb})}
\label{sec:gdb}

\version{14.2}

GNU Debugger (GDB) is a powerful debugging tool primarily designed to analyze and control the execution of programs written in C/C++ and other languages. It allows users to inspect memory, set breakpoints, step through code, and interact with running processes \cite{gdb-doc}.

One of GDB's key capabilities is attaching to a running process, which is specified with its process identifier (PID). Once attached, GDB can (apart from other control functionality) invoke functions directly from the process's symbol table. If the target process is linked against the C standard library (\texttt{libc}), the user can call the library functions, including system calls, within the GDB session. Thus, we can create a reverse shell with the correct set of functions.

To start a GDB session attached to the process with PID equal to \pid, we can use the option \texttt{-p} (or \texttt{-{}-pid=\pid}). It gives us an interactive terminal from which we can execute GDB commands.

\begin{cmdline}{*}{gdb}{}
gdb -p *\pid*
\end{cmdline}

The simplest use case involves invoking a shell command via the \texttt{system()} function from the \texttt{libc} library, which is commonly linked by many processes. Alternatives to \texttt{system()} include \texttt{execve()}, \texttt{popen()}, or any other standard C function capable of executing shell commands, as previously discussed in \cref{sec:gcc}. We use the Bash reverse shell presented in \cref{cmd:bash} as the function argument, but any other available method can also be used.

This function can be executed within a GDB session using the \texttt{call} command \cite{gdb-man}. Moreover, GDB allows passing commands from the command line through the \texttt{-ex} option. When used with the \texttt{--batch} option, GDB operates in batch mode, running the specified commands and exiting automatically afterwards. This enables the creation of a one-liner reverse shell.

\getcmdline{\commandpath{gdb-oneline.txt}}{*}{gdb}{}{GDB one-line reverse shell}{gdb-oneline}{
\dpd{a process with access to \texttt{system()} function form \texttt{libc} (or other function with similar effect)}
\notte{We used a \texttt{gdb} compiled without Python support (using the \texttt{--with-python=no} configuration option). For techniques involving \texttt{gdb} with Python support, see \cref{sec:compiled-with-python}.}
}

A key requirement for this technique is that the target process must include the desired function in its symbol table. However, any process with access to the function -- and running under the same user invoking GDB -- is equally usable. One can use the \inlinecmdline{ps aux} command to identify running processes.

Importantly, this method is not limited to standard functions. Any callable code -- whether from a third-party library or custom implementation -- capable of initiating a reverse shell can be leveraged through GDB, assuming the process has access to it. For instance, in cases where a reverse shell command (as shown in \cref{cmd:gdb-oneline}) cannot be executed due to missing tools, a reverse shell could still be constructed manually. This would involve using system calls to open a socket and receive commands, similar to the approach in \cref{code:c-code}. However, such a setup would be significantly more complex, requiring manual memory management and precise manipulation of pointers within the process's address space. A detailed example of manually programming a reverse shell inside a GDB session is beyond the scope of this thesis and depends heavily on the available running processes.


\subsection{Tools compiled with python support}
\label{sec:compiled-with-python}

Some system tools offer built-in support for executing Python code, provided they are compiled with the appropriate configuration. When such support is enabled, these tools can execute an arbitrary Python reverse shell code, including one with a reverse shell. In this section, we display three examples of such tools. We have tested these tools with the compressed code from \cref{code:python-script} (we will reference it as \script). We do not list dependencies for these examples because we used custom build for all tools, and thus, dependencies would be too specific. However, one could expect basic dependencies of the tool together with Python dependencies listed with \cref{code:python-script}.


\subsubsection{Vi IMproved (\texttt{vim})}

\version{9.1, with Python 3.12 support}

Vim is a text editor that is included by default in nearly all Linux distributions. It offers a wide variety of commands and can also have built-in scripting language interpreters if compiled that way -- not only for Python but also Ruby, Perl, Tcl, etc. This support is usually not enabled with default package installations and minimal builds and needs to be built manually -- \texttt{+python} (or \texttt{+python3} for Python3) build options \cite{vim-python-docs}. When compiled with this support, Python code can be executed directly within the editor using the \texttt{:pyx} command\footnote{or alternatively \texttt{:py2}/\texttt{:py3}/\texttt{:py} command, but \texttt{:pyx} choose Python version based on \texttt{pyxversion} setting \cite{vim-python-docs}}.

\getcmdline{\commandpath{vim-python.txt}}{*}{vim}{}{Vim reverse shell with Python support}{vim-python}{}

The \texttt{vim.command(":q!")} serves for quitting Vim after the end of the reverse shell. Also, equivalent usage could be used for \texttt{vim} variants -- \texttt{rvim} (remote-capable variant), \texttt{view} (read-only variant), \texttt{vimdiff} (launches Vim in diff mode), etc., which are essentially Vim invoked with different options.


\subsubsection{GNU Debugger (\texttt{gdb})}

\version{14.2}

We have already mentioned the GDB tool in \cref{sec:gdb} to use it for attaching it to running a process with access to functions capable of establishing a reverse shell. Furthermore, GDB can have built-in support for Python scripting. This Python integration is enabled in most modern builds of GDB. With it, users can execute Python code directly from the \texttt{gdb} prompt \cite{gdb-python-docs} without the need to attach it to a process with suited properties. We trigger the execution of Python script via \texttt{python} keyword.

\getcmdline{\commandpath{gdb-python.txt}}{*}{gdb}{}{GDB reverse shell with Python support}{gdb-python}{}


\subsubsection{Gimp (\texttt{gimp})}

\version{2.10.36, with Python-fu extension}

GIMP (GNU Image Manipulation Program) is a feature-rich graphics editor commonly found on desktop Linux systems. It offers a variety of plugins that can perform image manipulations. In addition, GIMP has several scripting extensions which allow for advanced non-interactive processing and creation of images \cite{gimp-man}. The extension supporting Python 2 is known as Python-fu (or \texttt{gimp-python} plugin) and used as the option \texttt{-{}-batch-interpreter=python-fu-eval}. However, starting with GIMP 3.0, the legacy Python-fu interface has been replaced with standard Python 3 support, which is not backward-compatible \cite{gimp-3}. As a result, most modern builds no longer include support for the \texttt{gimp-python} plugin.

We have tested the reverse shell with the older version of GIMP, but when using GIMP 3.0 with Python 3 support, use \texttt{python3} with the option \texttt{-{}-batch-interpreter}.

\getcmdline{\commandpath{gimp-python.txt}}{*}{gimp}{}{Gimp reverse shell with Python support}{gimp-python}{}

Newer versions of GIMP also support other scripting languages like Javascript, Lua and also C code \cite{gimp-3}.


\section{Encoded static binary}

In this thesis, we focused on reverse shell techniques that depend on tools available on the target system. These methods assume that the required tool(s) are either already present and functional on the compromised machine or can be supplementary installed by the attacker. They are practical and widely adopted, as they avoid introducing new malware to the system, thereby leaving fewer traces.

However, if we want to achieve a reverse shell without relying on any preinstalled tools -- or even dynamic libraries -- we need a statically linked binary in the form of malware. This malware could be any statically compiled code from \cref{sec:program-compilers}. In this section, we demonstrate an alternative approach to crafting such malware without using a compiler on the target system. The only requirement is a statically built tool or binary capable of executing a reverse shell\footnote{To be clear, it is required for the build of malware, not as an installed binary on the target's system.}. As an example, we use Netcat from the Nmap project, which supports static builds using the flags \texttt{LDFLAGS="-static"} and \texttt{CFLAGS="-static"}. We omit the full tutorial on how to build Nmap's Netcat and assume that the binary was built correctly -- we will refer to it as \texttt{./ncat-static}.

The key idea is to encode this binary using Base64, Hex, or any other binary-to-text encoding. The encoded binary can then be embedded into a simple script that, at runtime on the victim's machine, decodes the binary, writes it to a file with execute permissions, and runs it to establish the reverse connection. Since the embedded binary is statically compiled, it does not require any shared libraries or external dependencies.
The following example demonstrates exactly this approach.

\getcmdline{\commandpath{encoded-ncat.txt}}{*}{echo}{}{Embedding a reverse shell in a script using a statically linked NetCat binary}{encoded-ncat}{
\dpd{\texttt{base64}}
\notte{We copy the \shell\ (written as a path to the binary) into the file \tmp\ used for the decoded NetCat binary. This ensures that the \tmp\ file has the execute permission set. The same effect could be achieved by choosing any existing executable file as the target or using the standard \texttt{chmod} command to set the appropriate permissions.}
}

The crafted script first copies the \shell\ binary to a temporary file \tmp\ (this is done only to have execute permission on the \tmp\ file). It then decodes the embedded Base64-encoded contents of the statically compiled NetCat binary (\texttt{./ncat-static}) into the \tmp\ file. Finally, it runs the decoded Netcat binary (in \tmp) with the \texttt{-e} option to execute the shell, connecting to the specified host and port (see \cref{cmd:ncat1}). The crafted script is saved as the \script, which needs to be executed by the victim.

A cautious reader may notice that the command in \cref{cmd:encoded-ncat} still has one requirement on the target system -- the presence of the \texttt{base64} utility. However, this tool is only used to decode the embedded NetCat binary. If \texttt{base64} is not available, other encoding/decoding utilities such as \texttt{hexdump} or \texttt{od} for hexadecimal encoding can be used as alternatives. Since the binary is encoded into text characters, the resulting command can even be injected directly via command injection techniques, potentially bypassing the problem of transferring a malware file to the target system.

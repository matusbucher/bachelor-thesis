\chapter{Methods of establishing a reverse shell}
\label{chap:methods}

This chapter explores established methods and techniques for initializing a reverse shell from a remote server. Each method is characterized by a system tool, software, or a programming language with its interpreter/compiler. We will not categorize them by what misconfiguration could cause a vulnerability that these methods could exploit, since it heavily depends on the system and what services are running on it. However, we will talk about good practices and countermeasures against reverse shell in general in the \cref{chap:countermeasures}.

For each method, we show an actual command line example(s) of how to use the tool for the reverse shell, taking into account the testing environment described in the previous chapter. Furthermore, as mentioned, we list all system dependencies needed for the given method to execute successfully. If a method has excessive dependencies, such as dynamic libraries or modules, a complete list will be provided in the appendix A.


\section{Network tools}

First, we list the most apparent and straightforward candidates capable of creating a reverse shell: network tools. These tools are meant for network communication and can, therefore, be used really easily if they are available to the attacker.


\subsection{NetCat (\texttt{nc}/\texttt{ncat})}

\version{7.94SVN (Nmap Project)}

NetCat is a well-known tool for reading from and writing to network sockets using TCP or UDP and is preinstalled on many Linux distributions. There are multiple implementations of NetCat -- GNU's traditional implementation, OpenBSD, or the Nmap project version of NetCat called \texttt{ncat}, which we have used for testing.

Not every implementation supports the \texttt{-e} (or \texttt{-{}-exec}) or \texttt{-c} (or \texttt{-{}-sh-exec}) option, which causes the program to execute the given command. Option \texttt{-e} runs \texttt{exec <command>}, while \texttt{-c} executes via \texttt{/bin/sh} \cite{ncat-man}. The traditional GNU and the Nmap implementation should have this option, but the OpenBSD implementation has removed it for security reasons \cite{nc-man}.

\getcmdline{\commandpath{ncat1.txt}}{*}{ncat}{}{NetCat reverse shell (version 1, with option \texttt{-e})}{ncat1}{
\notte{Standard error output of executed commands is not redirected to the socket. Option \texttt{-c} can be used instead of \texttt{-e} with the same syntax, but \texttt{/bin/sh} is needed in that case.}
}

However, when dealing with NetCat without the \texttt{-e} or \texttt{-c} option, the restriction can be easily bypassed by redirecting file descriptors, as shown in the \cref{cmd:ncat2}. It creates a named pipe \tmp\ for connecting standard inputs and outputs of shell and NetCat processes.

\getcmdline{\commandpath{ncat2.txt}}{*}{mkfifo,ncat,rm}{}{NetCat reverse shell (version 2, with a named pipe)}{ncat2}{
\dpd{\texttt{mkfifo}}
}

\subsection{Telnet (\texttt{telnet})} \label{telnet}

\version{2.5 (GNU inetutils)}

Telnet is another popular client-server network protocol that establishes bidirectional interactive text-based communication using the TCP protocol (although now considered a legacy tool not recommended for secure communication). Unlike NetCat, Telnet does not offer a direct option to execute a command and send its output through the network. However, this limitation can be solved again by using standard Unix pipelines.

In the first example (\cref{cmd:telnet1}), we use two Telnet instances. One is for receiving commands that the chosen shell will execute, and then their output will be sent through the second telnet connected to a different port (it can also be connected to a different host). The attacker needs to set up two distinct listeners accordingly.

\getcmdline{\commandpath{telnet1.txt}}{*}{telnet}{}{Telnet reverse shell (version 1, with anonymous pipes)}{telnet1}{
\notte{The socket with port number \port\ serves as standard input for the shell while the socket with port number \portt\ serves as standard output and standard error output.}
}

Two Telnet instances were needed because anonymous Unix pipes are unidirectional. However, we can use a named pipe (like with NetCat) to create a reverse shell with only one telnet instance.

\getcmdline{\commandpath{telnet2.txt}}{*}{mkfifo,telnet,rm}{}{Telnet reverse shell (version 2, with a named pipe)}{telnet2}{
\dpd{\texttt{mkfifo}}
}


\subsection{Socat (\texttt{socat})}

\version{1.8.0}

Socat (short for SOcket CAT) is a versatile networking tool that acts as a bidirectional data relay between two data streams, such as TCP connections, UNIX sockets, or files. It is a more complex variant of NetCat with more flexibility and a vast number of options. Thus, running a reverse shell with Socat is really simple and convenient.

Socat uses many different ``address types'' (composed of an address type keyword and an optional argument) which give instructions and the necessary information for establishing the byte streams \cite{socat-man}. We will use the \texttt{tcp:<host>:<port>} type for connecting to the remote attacker and the \texttt{exec:<command-line>}, which runs the command as a forked subprocess and connects the standard input and output to the created socket. We can add \texttt{stderr} option to the \texttt{exec} address type, so it also redirects the standard error output.

\getcmdline{\commandpath{socat.txt}}{*}{socat}{tcp,exec}{Socat reverse shell}{socat}{}

Both \texttt{tcp} and \texttt{exec} address types have multiple additional options, which can be helpful in some scenarios. They can be appended right after the address types, separated with commas and no spaces. We list only a few options for \texttt{exec} address type (apart from the used \texttt{stderr} option) \cite{socat-man}:

\setlength{\leftmargini}{5em}
\begin{itemize}
\item[\texttt{nofork}] Does not fork a subprocess for executing the program, instead calls \texttt{execvp()} or \texttt{system()} directly from the actual socat instance.
\item[\texttt{pty}] Establishes communication with the sub-process using a pseudo-terminal instead of a socket pair. For this to function, \texttt{openpty} or \texttt{ptmx} device is necessary.
\item[\texttt{sigint}] Has \texttt{socat} pass the SIGINT signal to the sub process. Otherwise, sending this signal terminates the \texttt{socat} process.
\item[\texttt{sigquit}] The same as the \texttt{sigint} option, but with the SIGQUIT signal.
\end{itemize}
\setlength{\leftmargini}{2.5em}


\subsection{Socket (\texttt{socket})}

\version{1.1}

Socket is a relatively old, lesser-known network utility for creating and interacting with sockets directly from the command line. It does not usually come preinstalled (like NetCat) on most modern distributions. It has a \texttt{-p} (\texttt{program}) option, which runs the given command for each established connection, and its standard input, standard output, and standard error channels are automatically redirected to the socket \cite{socket-man}.

\getcmdline{\commandpath{socket.txt}}{*}{socket}{}{Socket reverse shell}{socket}{
\dpd{\texttt{/bin/sh} shell (\texttt{socket} executes the command specified with the \texttt{-p} option with this shell)}
}


\subsection{OpenSSL (\texttt{openssl})}

\version{3.0.13}

OpenSSL is a widely used toolkit that implements the SSL and TLS network protocols and related cryptography standards. It provides many commands with a variety of options and arguments, particularly for network connections between SSL/TLS clients and servers.

For the reverse shell, we will run the client on the victim's side. Since the client 'speaks' only in SSL/TLS, we need to establish a server on the attacker's side that also speaks in SSL/TLS. A simple NetCat listener will not be adequate, so we also use the \texttt{openssl} command to create a server on the attacker's side. It can be done using the \cref{cmd:openssl-listener}.

\getcmdline{\commandpath{openssl-listener.txt}}{*}{openssl}{}{Setting up an SSL/TLS server for catching OpenSSL reverse shell}{openssl-listener}{}

The first command (\texttt{openssl req}) generates a self-signed X.509 certificate and a new RSA 4096-bit key. Then, it saves the key and the certificate to the specified \texttt{.pem} files. The \texttt{-noenc} option makes the private key unencrypted (no password is required to access it later).

The second command (\texttt{openssl s\_server}) runs \texttt{openssl} in server mode for listening on a specified port. The certificate and key are loaded from the \texttt{.pem} files created with the first command, and the \texttt{-quiet} option will suppress the printing of session and certificate information (recommended, but not mandatory) \cite{openssl-doc}.

With the running SSL/TLS server, we can launch the client on the victim's machine and initialize the reverse shell with the \cref{cmd:openssl}.

\getcmdline{\commandpath{openssl.txt}}{*}{mkfifo,openssl,rm}{}{OpenSSL reverse shell}{openssl}{
\dpd{\texttt{mkfifo}}
}

We use the same technique with named pipe as we did with NetCat or Telnet methods. Here, the \texttt{-quiet} option is neccessary. It suppresses all non-essential output (session details, certificate verification info, and other debug output), which would not be valid input for the shell interpreter and probably cause it to exit or fail unpredictably. In our tests, the connection was closed immediately when we used the command without the \texttt{-quiet} option.


\subsection{cURL (\texttt{curl})}

\version{8.5.0}

cURL ("client for URL") is a versatile tool for transferring data to or from a server using various protocols, most commonly HTTP and HTTPS. In this reverse shell scenario, we will use \texttt{curl} command to periodically make HTTP requests to an attacker's server to fetch commands via the GET method and send back their output via the POST method.

Again, we will need a special listener on the attacker's side, this time an HTTP server that will handle the request as described earlier. We provide a simple Python script that should do the work (\cref{code:curl-listener}).

\getcode{\commandpath{curl-listener.txt}}{python}{*}{}{ShellHandler,do_GET,do_POST}{Setting up custom HTTP server for catching cURL reverse shell}{curl-listener}{}

With the \texttt{curl} command on the victim's side, we can send the mentioned GET and POST requests together with executing fetched commands in a loop (\cref{cmd:curl}).

\getcmdline{\commandpath{curl.txt}}{*}{curl}{}{cURL reverse shell}{curl}{}

Option \texttt{-s} (or \texttt{-{}-silent}) is for the silent mode, which does not print show progress meter or error messages, only the HTTP response. It is needed in the first \texttt{curl} command to get just the command without auxiliary output. Option \texttt{-X} (or \texttt{-{}-request}) specifies the request method, and option \texttt{-d} (or \texttt{-{}-data}) sends the specified data in a POST request. \cite{curl-man}

It is worth mentioning that this method uses a polling-based approach, which does not require a persistent TCP connection, unlike previous methods. Apart from appearing as common web traffic (and therefore harder to detect), the loop can persist even when the attacker becomes offline, so no additional actions on the victim's machine are required if the attacker wants to obtain the reverse shell again later.


\section{Command-line interpreters}

Another straightforward way to get a reverse shell is to use shell interpreters themselves. Since some shells have built-in support for simple TCP and UDP network communication, they can be used to connect to the attacker without using other system tools. This section lists all standard and popular shells capable of creating a reverse shell alone. At the end of the section, we also mention shell interpreters that do not support this feature (\cref{no-network-shells}).

The example commands in this section follow the \inlinecmdline{\shell\ -c '\textcolor{placeholder}{$\langle$command$\rangle$}'} format, where the \texttt{-c} option tells the shell to execute the given command string. All shell interpreters support this option mentioned in this section. If you are already running an interactive session in the given shell, you can execute just the \texttt{\textcolor{placeholder}{$\langle$command$\rangle$}} portion directly. However, we use the complete form for consistency and portability, ensuring the command works regardless of the current shell environment.


\subsection{Bash (\texttt{bash})}

\version{5.2.21 (GNU)}

First on the list is the default and most commonly used shell on most Linux distributions, the Bash shell. It was designed as a free and enhanced alternative for the classic Bourne shell (sh) and other proprietary Unix shells \cite{gnu-about}. It also offers extensive scripting capabilities and, importantly for this context, supports TCP and UDP communication through special file descriptors located in the \texttt{/dev/tcp/} and \texttt{/dev/udp/} pseudo-filesystems.

Bash treats these pseudo-file paths semantically like regular files, which allows standard input and output redirection to be used with them. This makes establishing a reverse shell connection possible using simple redirection syntax.

\getcmdline{\commandpath{bash.txt}}{*}{bash}{}{Bash reverse shell}{bash}{}


\subsection{Korn shell (\texttt{ksh}/\texttt{ksh93}/\texttt{rksh}/\texttt{rksh93})}

\version{93u+m/1.0.8 (ATT)}

Korn shell is a shell developed by David Korn as a successor to the Bourne shell. It was originally proprietary software, which led to the creation of several free and open-source alternatives, including Bash. There are actually many versions and clones of Korn shell, like \texttt{pdksh}, \texttt{mksh} and others, while the original is \texttt{ksh88}.

However, the version that added support for network communication is the newer \texttt{ksh93} version. It is realized through the same \texttt{/dev/tcp/} and \texttt{/dev/udp/} pseudo-filesystems as with Bash. Creation of reverse shell is thus done exactly as in the \cref{cmd:bash}.

\getcmdline{\commandpath{ksh.txt}}{*}{ksh}{}{Korn shell reverse shell}{ksh}{}

Additionally, there are two other clones of \texttt{ksh93} which also support this feature -- \texttt{dtksh} (Desktop Korn shell, a fork included as part of CDE) and \texttt{tksh} (a fork that provides access to the Tk widget toolkit) \cite{kornshell-wiki}. The Korn shell variants, which do not have networking features, are listed at the end of the section (\cref{no-network-shells}).

\subsection{Z shell (\texttt{zsh})}

\version{5.9}

Z shell is a feature-rich Unix shell offering advanced scripting capabilities and customization options. It is the default login shell on macOS and Kali Linux. Unlike Bash or Korn shell, Z shell does not support the \texttt{/dev/tcp/} or \texttt{/dev/udp/} pseudo-filesystems. Instead, additional features of the Z shell, including networking, are in modules, separate from the shell's core. Each module may be linked into the shell at build time or dynamically linked while the shell is running. \cite{zshmodules-man}

The module \texttt{zsh/net/tcp}, which provides manipulation of TCP sockets, can be loaded with the \texttt{zmodload} keyword. With the module loaded, we can run the \texttt{ztcp} command, which opens a new TCP connection to the specified host and port. The argument of option \texttt{-d} will be taken as the target file descriptor for the connection \cite{zsh-net-tcp-doc}. We can then redirect the standard input and output of the new shell session to this file descriptor.

\getcmdline{\commandpath{zsh.txt}}{*}{zsh}{}{Z shell reverse shell}{zsh}{
\dpd{\texttt{zsh/net/tcp.so} \footnote{usually located somewhere in \texttt{/usr/lib/}}}
}


\subsection{Scheme shell (\texttt{scsh})}

\TODO{maybe remove this method}

\subsection{Tcl shell (\texttt{tclsh})}

\TODO{}


\subsection{PowerShell (\texttt{pwsh}/\texttt{powershell})}

\version{7.5.0}

PowerShell is a powerful shell and scripting language developed by Microsoft. Unlike traditional shells, it is object-oriented. PowerShell comes preinstalled on modern Windows systems, but additionally, an open-source, cross-platform version -- \texttt{pwsh} -- is available for Linux and macOS. The following method is compatible on all platforms.

Reverse shell via PowerShell is more complicated than previous shells. To work with network connections, it requires using .NET classes and managing multiple objects such as sockets, streams, and others. Hence, we will need a PowerShell script rather than a simple command with redirections (this makes this method closer to the ``programming language interpreters'' category -- \cref{program-interpreters}). Nevertheless, it can still be made into a one-liner using the \texttt{-c} (or \texttt{-Command}) option and separating lines from the script with a semicolon (see \cref{cmd:pwsh-oneline}).

\getcode{\commandpath{pwsh-script.txt}}{bash}{*}{}{}{PowerShell reverse shell script}{pwsh-script}{
\dpd{\texttt{pwsh.dll} \footnote{usually located in \texttt{/opt/microsoft/powershell/}}, .NET}
}

To run the script saved as \scriptfile , execute the \texttt{pwsh} command with the option \texttt{-f} (or \texttt{-File}).

\getcmdline{\commandpath{pwsh-runscript.txt}}{*}{pwsh}{}{Running the PowerShell reverse shell script}{pwsh-runscript}{}

As mentioned, we can execute the PowerShell script as a one-line command by using the \texttt{-c} option.

\getcmdline{\commandpath{pwsh-oneline.txt}}{*}{pwsh}{}{PowerShell one-line reverse shell}{pwsh-oneline}{}


\subsection{Shells without native network support}
\label{no-network-shells}

In contrast to command-line interpreters that can independently establish network connections, we outline popular shells that lack this capability \cite{shell-comparison-wiki}. Without additional programs that facilitate network communication, these shells do not inherently pose a risk of spawning a reverse shell. However, this does not suggest that other security countermeasures should be disregarded when mitigating reverse shell attack vectors.

\begin{itemize}

\item \textbf{Bourne shell} (\texttt{sh}) -- The standard shell for the Version 7 Unix system; has been replaced by its advanced variants. Be aware that the original binary \texttt{/bin/sh} is just a link to another compatible shell on most modern Unix-like distributions.

\item \textbf{Almquist shell} (\texttt{ash}) and \textbf{Debian Almquist shell} (\texttt{dash}) -- Lightweight and POSIX-compliant shells designed for minimal environments, commonly used in embedded systems and as the default shell for Debian-based distributions.

\item The original Korn shell (\texttt{ksh88}), \textbf{Public domain Korn shell} (\texttt{pdksh}), \textbf{MirBSD Korn shell} (\texttt{mksh}), \textbf{Portable OpenBSD Kown shell} (\texttt{oksh}) and other variants and forks not based on \texttt{ksh93}.

\item \textbf{C shell} (\texttt{csh}) and \textbf{TENEX C shell} (\texttt{tcsh}) -- Shells with a syntax inspired by the C programming language. \texttt{tcsh} extends \texttt{csh} with interactive features like command-line editing and history.

\item \textbf{Friendly interactive shell} (\texttt{fish}) -- A user-friendly shell with advanced features like syntax highlighting, autosuggestions, and a scripting syntax distinct from POSIX-compliant shells.

\item \textbf{rc shell} (\texttt{rc}) -- The default shell for the Plan 9 operating system, also available on Unix systems.

\item \textbf{Stand-alone shell} (\texttt{sash}) -- A statically linked shell designed for system recovery and emergency maintenance.

\item \textbf{Command Prompt} (\texttt{cmd}) -- The default legacy command-line interpreter for Windows.

\end{itemize}


\section{Programming language interpreters}
\label{program-interpreters}

In this section, we cover common interpreted programming or scripting languages. Every proper programming language should be capable of opening a TCP socket for network communication (perhaps with some standard module), running a command from the operating system, redirecting standard file descriptors to the socket â€” and, therefore, creating a reverse shell. The interesting part is which dynamic libraries and modules are requisite for each method.

Almost all examples in this section are written as script files, but, as with the PowerShell example (\cref{code:pwsh-script}), they can easily be turned into one-liners with specific options or pipelines. We will specify how to do this for each method. The example scripts also include comments with decent explanations of what the script does.


\subsection{Python (\texttt{python/python3})}

\version{3.12.3}

Python is one of the most popular programming languages, known for its simple, readable syntax and vast standard library. Among the example scripts in this section, the following one for Python reverse shell is relatively short and straightforward. It also requires a small number of Python modules.

\getcode{\commandpath{python-script.txt}}{python}{*}{}{}{Python reverse shell script}{python-script}{
\dpd{Python modules (see \cref{tab:python-dpd} in the appendix A)}
}

\getcmdline{\commandpath{python-runscript.txt}}{*}{python}{}{Running the Python reverse shell script}{python-runscript}{}

Now, the script can be turned into a one-liner using Python's \texttt{-c} option and separating lines with semicolons \cite{python-man}. The for loop, however, must be compressed to a list comprehension as \inlinecmdline{[os.dup2(sock.fileno(),fd) for fd in (0,1,2)]} or expanded into three separate lines (one for each file descriptor).

\getcmdline{\commandpath{python-oneline.txt}}{*}{python}{}{Python one-line reverse shell}{python-oneline}{}

\subsubsection{Pip (\texttt{pip})}

\version{24.0 (python 3.12)}

Pip is the default package manager for Python, used to install and manage third-party libraries from the Python Package Index (PyPI). Most distributions of Python come with the \texttt{pip} tool preinstalled. While primarily intended for managing dependencies in software projects, Pip can be misused to execute arbitrary Python code during package installation via a specially crafted \texttt{setup.py} script. This file should contain the package's metadata and installation instructions, and Pip automatically searches for it and executes it to build and install the package \cite{pip-install-doc}.

So, we can use the Python script for reverse shell (see \cref{code:python-script}) as the \texttt{setup.py} file, and then give the directory in which this file is as the argument to the \texttt{pip install} command. For clarity and a general case, we use a temporary directory \tmp\ to place the custom \texttt{setup.py} file.

\getcmdline{\commandpath{pip.txt}}{*}{mkdir,echo,pip,rm}{}{Pip reverse shell}{pip}{
\dpd{\TODO{}}
}

We need to use the \texttt{-{}-break-system-packages} option in case of the externally managed environment \cite{pip-install-doc}. That is when the Python installation is marked as ``externally managed'' by the OS package manager (like \texttt{apt}) and the \texttt{pip} tool is about to install packages ``system-wide'', which could overwrite system-managed Python packages (and thus break some functionality that depends on those packages). We are not overwriting any system packages in our case, but it is an additional security permission that the \texttt{pip} tool requires.


\subsection{Perl (\texttt{perl})}

\version{5.38.2}

Perl is a high-level language designed as a general-purpose Unix scripting language to facilitate report processing. Although less commonly used today than Python or other scripting languages, Perl remains a staple in many legacy systems. The script for the reverse shell is, again, really straightforward, with a few dependent modules.

\getcode{\commandpath{perl-script.txt}}{perl}{*}{}{}{Perl reverse shell script}{perl-script}{
\dpd{\texttt{/dev/null}, Perl modules (see \cref{tab:perl-dpd} in the appendix A), loadable object \texttt{auto/Socket/Socket.so} (for module \texttt{Socket})}
}

\getcmdline{\commandpath{perl-runscript.txt}}{*}{perl}{}{Running the Perl reverse shell script}{perl-runscript}{}

To make it into a one-line command, use the \texttt{-e} (or \texttt{-E}) option with the compressed script \cite{perl-man}.

\getcmdline{\commandpath{perl-oneline.txt}}{*}{perl}{}{Perl one-line reverse shell}{perl-oneline}{}

\subsubsection{Comprehensive Perl Archive Network (\texttt{cpan})}
\label{cpan}

\version{Perl 5.38.2}

CPAN is a large repository of Perl modules and libraries. It is typically accessed using the \texttt{cpan} command-line tool, which allows users to search for, install, and manage Perl modules directly from the terminal. When run without arguments, the tool starts an interactive CPAN session, where the exclamation mark (\texttt{!}) executes arbitrary commands. While this feature is intended to allow running shell commands (such as \inlinecmdline{! ls}), it can also interpret and execute valid Perl code \cite{cpan-man}.

Hence, we could start the \texttt{cpan} session and enter the compressed Perl code from \cref{code:perl-script} prefixed with \texttt{!}. We can also pass the line to \texttt{cpan} through a pipeline with the \texttt{echo} command, as shown below.

\getcmdline{\commandpath{cpan-oneline.txt}}{*}{echo,cpan}{}{Cpan one-line reverse shell}{cpan-oneline}{
\dpd{\texttt{perl}, dependencies from \cref{code:perl-script} (except \texttt{/dev/null}), additional Perl modules and loadable objects (see \cref{tab:cpan-dpd-mod,tab:cpan-dpd-so} in the appendix A)}
}


\subsection{PHP (\texttt{php})}

\version{8.3.6}

PHP is a widely used server-side scripting language. It is primarily designed for web development but capable of general-purpose scripting. It has built-in networking and process control functions, allowing quick and effective reverse shell implementations. That makes PHP reverse shell especially useful in web-based attack scenarios like file upload or remote code execution vulnerabilities.

Our minimal example of a PHP reverse shell consists of only two function calls. Since these functions are part of PHP's core, loading additional modules is not required (which makes the dependency list minimalistic).

\getcode{\commandpath{php-script.txt}}{php}{*}{}{}{PHP reverse shell script}{php-script}{
\dpd{\texttt{UTC} file\footnote{usually located in \texttt{/usr/share/zoneinfo/}; without it, the \texttt{php} tool does not work at all}, \texttt{sh} shell (\texttt{php} uses it to execute commands)}
\notte{This will fork the shell session without the need to use \texttt{\&} in the command passed to the \texttt{proc\_open()} function.}
}

We can use the option \texttt{-f} (or \texttt{--file}) to execute the script (but it also works without the option, when we pass the filename as the only argument).

\getcmdline{\commandpath{php-runscript.txt}}{*}{php}{}{Running the PHP reverse shell script}{php-runscript}{}

The option \texttt{-r} (or \texttt{-{}-run}) of the PHP command line tool allows us to run the code as one command \cite{php-man}. However, we must omit the PHP opening and closing tags (\texttt{<?php} and \texttt{?>}) in the compressed script.

\getcmdline{\commandpath{php-oneline.txt}}{*}{php}{}{PHP one-line reverse shell}{php-oneline}{}

Additionally, the \texttt{proc\_open()} call can be substituted with other functions that accept only the command argument without the descriptor specification. This can be fixed using standard shell redirections as part of the command passed to the function. The \texttt{fsockopen()} call assigns the first available file descriptor number to the opened socket, which we can use for the shell redirections. However, this number differs when executing the script from a file or with the \texttt{-r} option from the command line. In the first case (\cref{cmd:php-runscript}), the assigned file descriptor should be number 4, while in the second case (\cref{cmd:php-oneline}) it should be number 3\footnote{We have not investigated further why this is so; we have identified the numbers just from testing}. We will refer to this number as \fd.

Also, be aware that the \texttt{\$sock} variable (to which the return value of \texttt{fsockopen()} call is assigned) is still needed even with the substituted functions, which do not directly use this variable, because otherwise the socket would be closed immediately by PHP garbage collection. Finally, these are the functions that can be used instead of \texttt{proc\_open()} one:

\begin{itemize}

\item \inlinecmdline{exec("\shell\ <\&\fd\ >\&\fd\ 2>\&\fd ")}
\item \inlinecmdline{system("\shell\ <\&\fd\ >\&\fd\ 2>\&\fd ")}
\item \inlinecmdline{shell\_exec("\shell\ <\&\fd\ >\&\fd\ 2>\&\fd ")} or \inlinecmdline{`\shell\ <\&\fd\ >\&\fd\ 2>\&\fd `} (with the backtick symbols) -- these are semantically equivalent
\item \inlinecmdline{passthru("\shell\ <\&\fd\ >\&\fd\ 2>\&\fd ")}
\item \inlinecmdline{popen("\shell\ <\&\fd\ >\&\fd\ 2>\&\fd ", "r")}

\end{itemize}


\subsection{Lua (\texttt{lua})}

\version{5.3.6}

Lua is a lightweight, embeddable scripting language designed primarily for integration into other applications. It is widely used in game development, embedded systems, and configuration scripting. The LuaRocks package manager (\texttt{luarocks}) allows users to extend the language's minimal core by installing additional packages.

We need the \texttt{socket} library for a reverse shell from the \texttt{luasocket} package. To install it, we issue:

\begin{cmdline}{*}{luarocks}{}
luarocks install luasocket
\end{cmdline}

However, the following script depends on only two files from the package (see \textbf{Dependencies}).

\getcode{\commandpath{lua-script.txt}}{[5.0]Lua}{*}{}{}{Lua reverse shell script}{lua-script}{
\dpd{\texttt{sh} shell (\texttt{os.execute()} uses it to execute the command), Lua \texttt{socket} module\footnote{\texttt{.lua} file, usually located in \texttt{/usr/share/lua/<version>/}} and loadable object \texttt{socket/core.so}\footnote{usually located somewhere in \texttt{/usr/lib/} under \texttt{lua/<version>} directory}}
}

\getcmdline{\commandpath{lua-runscript.txt}}{*}{lua}{}{Running the Lua reverse shell script}{lua-runscript}{}

Another option, though kind of redundant, is compiling the Lua code with \texttt{luac} compiler and then running the compiled code with \texttt{lua} interpreter. We can also run the script directly from the command line using Lua's \texttt{-e} option.

\getcmdline{\commandpath{lua-oneline.txt}}{*}{lua}{}{Lua one-line reverse shell}{lua-oneline}{}


\subsection{Ruby (\texttt{ruby})}

\version{3.2.3}

Ruby is a dynamic, object-oriented programming language known for its clean syntax and focus on developer productivity. It is widely used in web development (notably with Ruby on Rails, a server-side web application framework) but functions well as a general-purpose scripting language.

The simplicity of the Ruby language makes the reverse shell script again pretty straightforward. We present two fundamentally different versions -- the first redirects standard file descriptors and replaces the process with the given shell; the second reads commands from the socket, executes them with the \texttt{sh} shell, and sends the output back to the socket in a loop. Both scripts require only one module.

\getcode{\commandpath{ruby-script1.txt}}{ruby}{*}{}{}{Ruby reverse shell script (version 1)}{ruby-script1}{
\dpd{Ruby module \texttt{socket}\footnote{\texttt{.rb} file, usually located in \texttt{/usr/lib/ruby/<version>/}} and loadable object \texttt{socket.so}\footnote{usually located somewhere in \texttt{/usr/lib/} under \texttt{ruby/<version>} directory}}
}

\getcode{\commandpath{ruby-script2.txt}}{ruby}{*}{}{}{Ruby reverse shell script (version 2)}{ruby-script2}{
\dpd{same dependencies from \cref{code:ruby-script1}, \texttt{sh} shell (\texttt{popen()} function uses it to execute the command)}
}

\getcmdline{\commandpath{ruby-runscript.txt}}{*}{ruby}{}{Running the Ruby reverse shell script}{ruby-runscript}{}

The \texttt{ruby} tool supports option \texttt{-e}, which can turn the scripts into one-line commands \cite{ruby-man}.

\getcmdline{\commandpath{ruby-oneline.txt}}{*}{ruby}{}{Ruby one-line reverse shell}{ruby-oneline}{}


\subsubsection{Interactive Ruby Shell (\texttt{irb})}

\version{1.6.2}

Ruby also comes with an interactive shell called IRB (Interactive Ruby), which allows users to execute Ruby code line by line directly from the terminal. Similarly to the \texttt{cpan} (\cref{cpan}) tool, we can pass the compressed script (either \cref{code:ruby-script1} or \cref{code:ruby-script2}) to the \texttt{irb} through a pipeline.

\getcmdline{\commandpath{irb-oneline.txt}}{*}{echo,irb}{}{IRB one-line reverse shell}{irb-oneline}{
\dpd{\texttt{ruby} \footnote{or \texttt{ruby<version>}, since some modules explicitly call this binary}, dependencies from either \cref{code:ruby-script1}\ or \cref{code:ruby-script2}, \texttt{/dev/null}, additional Ruby modules, loadable objects and special gemspec files (see \cref{tab:irb-dpd-mod,tab:irb-dpd-so,tab:irb-dpd-gemspec} in the appendix A)}
}


\subsection{JavaScript runtime environments}

\subsubsection{Node.js (\texttt{node})}

\version{18.19.1}

\getcode{\commandpath{node-script.txt}}{java}{*}{}{}{Node.js reverse shell script (JavaScript)}{node-script}{
\dpd{JavaScript modules (see \cref{tab:node-dpd} in the appendix A)}
}

\getcmdline{\commandpath{node-runscript.txt}}{*}{node}{}{Running the Node.js reverse shell script}{node-runscript}{}

\getcmdline{\commandpath{node-oneline.txt}}{*}{node}{}{Node.js one-line reverse shell}{node-oneline}{}


\subsubsection{Nashorn engine (\texttt{jjs} and \texttt{jrunscript})}

\version{1.8.0\_442}

\getcode{\commandpath{nashorn-script.txt}}{java}{*}{}{}{Nashorn engine reverse shell script (JavaScript)}{nashorn-script}{
\dpd{\TODO{}}
}

\getcmdline{\commandpath{jjs-oneline.txt}}{*}{echo,jjs}{}{jjs one-line reverse shell}{jjs-oneline}{}

\getcmdline{\commandpath{jrunscript-oneline.txt}}{*}{jrunscript}{}{jrunscript one-line reverse shell}{jrunscript-oneline}{}


\subsection{Julia (\texttt{julia})}

\version{1.11.4}

Julia is a high-level, high-performance programming language designed primarily for numerical and scientific computing \cite{julia-intro}. It combines the flexibility of dynamic languages with the speed of compiled languages through just-in-time (JIT) compilation. Julia typically runs like a scripting language through its interactive runtime, but it also supports packaging code into standalone binaries \cite{julia-compiler}. Additionally, Julia excels in interoperability -- it can call libraries written in languages like C or Rust, and Julia packages themselves can be accessed from languages like Python or R \cite{julia-calling-c}.

Naturally, Julia provides socket programming functionality, making it capable of creating a reverse shell.

\getcode{\commandpath{julia-script.txt}}{perl}{^}{}{}{Julia reverse shell script}{julia-script}{
\dpd{dynamic libraries (see \cref{tab:julia-dpd} in the appendix A), Julia module \texttt{Sockets} (files \texttt{Sockets.jl} and \texttt{Sockets/Project.toml}\footnote{usually located in \texttt{/usr/local/share/stdlib/<version>}})}
}

\getcmdline{\commandpath{julia-runscript.txt}}{*}{julia}{}{Running the Julia reverse shell script}{julia-runscript}{}

Jullia command-line interface comes with the option \texttt{-e} (or \texttt{-{}-eval}), which can evaluates the compressed reverse shell script.

\getcmdline{\commandpath{julia-oneline.txt}}{*}{julia}{}{Julia one-line reverse shell}{julia-oneline}{}


\section{Compiled programs}
\label{program-compilers}

So far, we have mentioned reverse shell methods that utilize one or more software tools with a CLI to establish a connection back to the attacker. Another approach is running an executable from compiled code. In this subsection, we list methods that require compilation (not necessarily into machine code, see \cref{java}) before running and, therefore, cannot be executed directly from the command line. We will focus on one specific compiler for each considered language, since analyzing dependencies for each available compiler would be complicated and is beyond the scope of this thesis.

\subsection{C/C++ (\texttt{gcc})}

\version{13.3.0}

First on the list are the classic C and C++ (since all C code is valid C++ code) and the \texttt{gcc} (GNU Compiler Collection) compiler. Although any C compiler can be used to compile the example code, dependencies have been analysed only for the \texttt{gcc} compiler (version 13).

C is a low-level, system-oriented language that provides direct access to memory and system calls. Many tools mentioned in this thesis are themselves implemented in C. However, the low-level nature of the language means that the code is not as clean as with other high-level languages. The basic explanation of the code can be found in the comments.

\getcode{\commandpath{c-code.txt}}{C}{|}{}{}{C/C++ reverse shell code}{c-code}{
\dpd{\texttt{gcc}\footnote{or other standard \texttt{C} compiler, but it would probably required different dependencies}, \texttt{as} (GNU assembler), \texttt{ld} (GNU linker), \texttt{cc1}\footnote{component of \texttt{gcc} that compiles source code to assembly, usually located in \texttt{/usr/libexec/gcc/<architecture>/<gcc-version>}}, static and dynamic libraries and header files (see \cref{tab:c-dpd-lib} and \cref{tab:c-dpd-include} in the appendix A)}
}

\getcmdline{\commandpath{c-runcode.txt}}{*}{gcc}{}{Compiling and running the C/C++ reverse shell code}{c-runcode}{
\notte{The \texttt{-o} option can be omitted -- in that case, the created binary will have the default \texttt{a.out} file name \cite{gcc-man}.}
}

The GCC compiler offers plentiful options. Perhaps the most interesting ones are these \cite{gcc-man}:

\setlength{\leftmargini}{5em}
\begin{itemize}
\item[\texttt{-static}] Links the libraries statically, producing a self-contained binary that does not depend on shared libraries at runtime, but takes more space.
\item[\texttt{-Os}] Optimize for smaller size.
\item[\texttt{-s}] Strips the symbol table and relocation information from the executable, making the final binary smaller.
\end{itemize}
\setlength{\leftmargini}{2.5em}


\subsection{Java (\texttt{javac})}
\label{java}

\version{21.0.6}

\getcode{\commandpath{java-code.txt}}{Java}{*}{}{}{Java reverse shell code}{java-code}{
\dpd{\TODO{}}
}

\getcmdline{\commandpath{java-runcode.txt}}{*}{javac}{}{Compiling and running the Java reverse shell code}{java-runcode}{}


\subsection{Golang (\texttt{go})}

\version{1.22.2}

\getcode{\commandpath{go-code.txt}}{Golang}{*}{}{}{Go reverse shell code}{go-code}{
\dpd{\TODO{}}
}

\getcmdline{\commandpath{go-runcode.txt}}{*}{go}{}{Compiling and running the Go reverse shell code}{go-runcode}{}


\section{Other tools}

\subsection{Gawk (\texttt{gawk})}

\version{GNU Awk 5.2.1}

AWK is a text-processing and pattern-scanning language commonly used in Unix-like systems for data manipulation tasks. Initially developed to work with textual data stored in files, it was never meant for networking purposes \cite{gawk-doc}.

Its GNU implementation, gawk, extends the standard AWK features with more powerful capabilities, including built-in support for network communication. Specifically, gawk allows the use of special file names in the form of

\qquad \texttt{/net-type/protocol/localport/hostname/remoteport}

together with the \texttt{|\&} coprocess operator for creating TCP/IP network connections \cite{gawk-man}. We will provide the example in the form of an AWK script, as we did in the previous sections, but it can be executed directly from the command line.

\getcode{\commandpath{gawk-script.txt}}{awk}{*}{}{}{Gawk reverse shell script}{gawk-script}{}

Since the gawk's coprocess feature (the \texttt{|\&} operator) captures only the standard output of the command, while the coprocess's standard error goes to the same place as gawk's standard error \cite{gawk-io}. So we need to explicitly redirect it to standard output within the command string itself. This was done by appending \texttt{2>\&1} to the command \texttt{c}.

It is also vital to close the command's streams after execution because each shell command that the attacker runs through the reverse shell is associated with a separate process (or opened file). If you attempt to execute the same command again without closing the previous instance, gawk will reuse the existing process, which could lead to unexpected results \cite{gawk-close}. Closing the coprocess also saves system resources.

Next, we show how to run the script file (option \texttt{-f} or \texttt{--file}) or execute the script from the command line.

\getcmdline{\commandpath{gawk-runscript.txt}}{*}{gawk}{}{Running the Gawk reverse shell script}{gawk-runscript}{}

\getcmdline{\commandpath{gawk-oneline.txt}}{*}{gawk}{}{Gawk one-line reverse}{gawk-oneline}{}

\subsection{Tools compiled with python support}

\TODO{gdb, gimp, vim, vimdiff, rvim, view, rview}

\chapter{Framework for analysis}
\label{Testing framework}

\label{chap:framework}



\section{Testing environment}

In our analysis, the victim machine (on which techniques for establishing a reverse shell are tested) is simulated with a \texttt{chroot} environment for simplicity. The \texttt{chroot} command allows running a command or interactive shell with a specified directory as the apparent root directory \cite{chroot-man}. Therefore, the system simulated in the \texttt{chroot} environment has only access to files in the new 'root directory', which is convenient for determining requirements for a given method. If the method does not work, the environment may lack some libraries, system tools, devices, etc.

The host system distribution (from which the \texttt{chroot} command is executed) is Ubuntu 24.04 LTS with a Linux 5.15 kernel and 64-bit x86 architecture. However, the commands and tools tested in this thesis should work on all GNU/Linux-based systems (if all dependencies are present).

The specifications for the attacker machine do not matter; some methods require a slightly more complex listening setup than just opening a port, which we will discuss later.

\section{Commands syntax and glossary}

For each system tool, we list one or more commands that, when run on the victim's machine, should try to connect to the attacker's machine (mainly using TCP), spawn a new shell session, and redirect its standard input and output to the connected socket.

The attacker must have an open port (can be any available) and listen for any connection on that port. In most cases, a simple netcat command should be sufficient for that:

\begin{cmdline}{bash}{*}{nc}{}
nc -lp *\port*
\end{cmdline}

The non-obligatory option \texttt{-v} can be added for more verbose output. If the given method requires a more complex setup on the attacker's side, we will provide the necessary commands for the setup with an explanation.

The commands in this thesis use placeholders instead of specific values for generalization. They ensure clarity and adaptability across different scenarios, whether the actual value depends on the execution environment -- such as IP address -- or multiple equivalent values can be chosen -- such as the name of a temporary file. When implementing or testing, these placeholders should be replaced accordingly:

\setlength{\leftmargini}{5em}
\begin{itemize}
\item[\host] The attacker's IP address or domain.
\item[\port] The port number on which the attacker is listening.
\item[\shell] The shell to be spawned (e.g. \texttt{/bin/sh}, \texttt{/bin/bash}).
\item[\portt] The second port number on which the attacker is listening; must be different from \port.
\item[\tmp] A temporary file or directory used in specific methods (e.g., pipeline creation).
\end{itemize}
\setlength{\leftmargini}{2.5em}

\host\ and \port\ are naturally required in every method. \shell\ is also usually required and can be substituted with any available shell interpreter on the target system, even with a self-made interactive script or any other command. The standard input, output, and error output are all redirected to the socket. Therefore, the attacker can interact remotely with the shell (or another command).

\portt\ and \tmp\ are used only in several methods. \portt\ is, for instance, needed in telnet reverse shell (see \cref{lst:telnet1}), where the socket on port number \port\ serves as input for the shell and the socket on port number \portt\ serves as output. \tmp\ is used when the method requires a named pipeline (see \cref{lst:ncat2}) or a temporary directory for generated files (see \cref{lst:pip}).

If you would like to fork the reverse shell to run in the background (while the parent process -- e.g., shell -- will be running), add ampersand (\texttt{\&}) at the end of a command. A similar effect can be achieved if the command spawns \shell\ via shell interpreter (which most methods do, e.g., bash methods), in which case you can append ampersand at the end of this ``nested'' command.

After each command, it may follow a list of dependencies and occasional notes if additional information is appropriate. The implicit dependency for each command is that all shared objects (libraries) the binary requires are in the system. Of course, this is not an issue when using a statically linked binary. To identify all shared objects of the tool, use the \texttt{ldd} command:
\begin{cmdline}{bash}{*}{ldd}{}
ldd *\textcolor{placeholder}{\texttt{$\langle$path-to-binary$\rangle$}}*
\end{cmdline}
